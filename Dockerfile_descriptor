Docker.

Идеология докера выросла из необходимости перевозить грузы на кораблях.
Каждому грузу требовалась индивидуальная тара, индивидуальный способ погрузки, крепления, а также индивидуальные особенности перевозки, условия сохранности и разгрузки.
Впоследствии были изобретены контейнеры, поместить в которые можно что угодно. Ключевая особенность контейнеров - их стандартизация. На них стандартизированные крепления, с помощью которых можно и погрузить, и закрепить, и выгрузить контейнер на любой корабль, у них стандартизированные способы открытия, закрытия (не нужно индивидуально запаковывать каждый груз, и каждый раз решать головоломку как его раскрыть).

Контейнер в ОС - это то же самый унифицированный контейнер, который можно запустить и перевезти на любом корабле (на любой операционной системе).

Основные особенности контейнеризации в технологии докер.

1. Стандартизация. Стандартизация включает в себя три пункта:
    Сборка.
(Вся сборка сводится к команде docker build и описанного заранее Dockerfile)
    Поставка.
(Запуск любого приложения сводится к команде docker run)
    Конфигурация.
(Все приложения конфигурируются одинаково. Хороший тон - задавать всю конфигурацию и все переменные окружения не из командной строки, а унифицировано в Dockerfile)

2. Воспроизводимость.
    Любой docker image можно воспроизвести на любом *nix-хосте.
3. Консистентность.
    Запуск в тестовом окружении и запуск на проде идентичны.

Контейнер.
Namespace - механизм ядра Linux, обеспечивающий изоляцию процессов друг от друга (PID, Net, Mnt, User). 
1. PID NS (пространство имён идентификаторов процессов внутри Linux).
* Изоляция:
процессы в PID ns видят только процессы в этом же ns.
* У каждого PID ns своя нумерация, начинающаяся с 1.
    Если контейнер запущен через ENTRYPOINT какой-то командой или приложением, то этот ENTRYPOINT или команда запускают один процесс с PID 1.
    Как только этот процесс завершится, работа контейнера будет автоматически завершена. (Linux система не может существовать без PID 1).
2. NET NS.
Процессы в рамках своего net ns получают своё сетевое окружение. Шю уюЖ
    Сетевые интерфейсы (и свой собственный localhost).
    Таблицу маршрутизации
    Правила фильтрации (iptables, et cetera)
    Сокеты
Таким образом, процесс, который существует в своём сетевом ns видит всю сеть так, будто запущен на собственном хосте, но хост его - контейнер.
Veth.
    Из предыдущей мысли следует, что нам нужно соединить сетевой интерфейс внутри контейнера с сетью на самой ноде того хоста, где запущен контейнер.
    (По умолчанию их соединяет связь типа bridge).
Так же в Докере несколько процессов могут быть объединены в один общий localhost.

3. MNT NS.
При каждом запуске контейнера из образа, контейнер получает свою собственную новую файловую систему.
В рамках mount ns процессы могут иметь:
    свою собственную root fs.
    свои собственные приватные точки монтирования файловых систем, типа:
        /tmp, /sys, /proc

Инода приложение требует настройки ядра для оптимизации своей работы.
По умолчанию все контейнеры работают на одном общем ядре операционной системы, и вроде как мы не можем настроить ядро конкретно для каждого контейнера.
Но на самом деле не все правила внутри systemctl являются ns-независимыми, и некоторые правила мы можем настраивать для каждого ns в отдельности.
Это достигается благодаря mnt ns: /sys и /proc для каждого контейнера, например.
Список параметров в ядре, которые мы можем тюнить отдельно для каждого контейнера. Почитать.

4. USER NS.
Позволяет отображать и приводить в соответствие GID/UID в контейнере в GID/UID на хосте.
    Например, привести рутовый PID с контейнера в нерутовый на хосте, чтобы избежать утечек безопасности.

Control groups.
Cgroup - механизм ядра Linux, изолирующий вычислительные ресурсы процессов ( CPU, Mem, I\O, Net).
(Управляет ресурсами для процесса).

--default-ulimit - команда ограничений для докер-демона.
--dns - переопределение dns, которые используются для серверов на данном хосте.
--insecure-registry - при обращении к некоторым registry, не требовать лишних ресурсов для установления защищённого соединения (если оно в локальной защищённой сети).

Copy-on-Write.
При чтении области данных используется общая копия.
В случае изменения данных - создаётся новая копия.

Storage driver.
Бэкендовая файловая система, позволяющая докеру выполнять Copy-on-Write.

Виды драйверов:
Devicemapper (Centos < 3.10.0-514, Fedora).
Overlay and Overlay2. (Centos > 3.10.0-514)
AUFS. (Debian, Ubuntu).
BTRFS.

Log driver.
Перенастраиваются на различные ПО, базовые настройки довольно слабые.

docker info | grep Driver

Docker workflow (example).
1. Work with Dockerfile.
Описание того, что должно собираться в образе для приложения:
Операционная система, библиотеки, модули языка, код.
2. Build. Сборка по Dockerfile. CI/CD.
3. Run. Test container.
Запуск со всеми зависимостями: бд, redis, kafka.
4.  Registry.
docker push - load images into registry
docker pull - вытягивание образа.
5. Deploy.

1. Пишем стандартный Dockerfile.
1.a. Если нужно - Docker-compose.
Утилита Docker-compose позволяет в одном файле (docker-compose.ym) описать инфраструктуру для проекта любой сложности, поднимая его со всеми зависимостями, в т. ч. бд и т. д.
docker-compose up -d
2. Сборка образа.
3. Запуск окружения.
4. Registry
4.a. Вопросы аутентификации и доступа.
4.b. Ротация образов.
Если образов много, они начинают занимать огромное количество информации.
4.c. Поэтому registry должно уметь очищать по какому-то параметру старые образы (хранящиеся больше года, или хранящие только последний 10 версий с каждой ветки).
4.d. Hook API.
Hook - это?
4.e. Хранение других сущностей (не только образов).
E. g. хранение helm'ов.

Краткая памятка по оптимизации:
1. Нужно адаптировать приложения
(особенно, которые не писались под Docker)
E. g. java, которая считывает вычислительную мощность машины.
2. Нужна тщательная проработка архитектуры.
(взаимосообщаемость разных микросервисов и зависимостей)
3. Для эффективного использования требуется много дополнительных сущностей.

Краткий глоссарий:

Образ (image) - базовое понятие, представляющее собой минимальное окружение для запуска контейнера.
Это образ, заранее собранный при помощи Dockerfile'a. Выполненный и запакованный в формат докера команды и ключевые слова, находящиеся в Dockerfile.
Из такого image можно запустить негораниченное количество контейнеров в рамках одной локальной машины.
Перечни образов хранятся в Docker hub или docker repository.
E. g. (exempli gratia):
Ubuntu - голая убунту.
Python - Минимальная linux-os + python.

Командой docker pull <image-name>, этот образ скачивается в ваш локальный репозиторий.
(По умолчанию скачивается с тегом latest, но через двоеточие можно указывать нужную нам версию).
(e. g. openjdk:jre-slim).

Дальше выполняется команда docker run <image-name> и этого достаточно, чтобы играться с ним как в песочнице, но недостаточно, чтобы запустить полноценный микросервис.

Для того, чтобы запустить полноценный микросервис, нам нужно установить на этот базовый образ свои собственные настройки, например, сделать
sudo apt update && sudo apt upgrade
sudo apt install something-cool

Но и этого недостаточно, если нам нужно засунуть в него свой код, перенести свои файлы и пр.

Чтобы этого не делать каждый раз вручную, был придуман волшебный Dockerfile.

Типичный формат Докерфайла выглядит так:

INSTRUCTION аргументы для выполнения этой инструкции.
(INSTRUCTION, при этом нечувствительная к регистру, но принято писать её капсом для более лёгкой читаемости).

Dockerfile всегда начинается с инструкции: FROM
FROM указывает адрес исходного образа, на основе которого мы будем строить свой контейнер.

Каждая последующая инструкция (типа ADD, COPY, RUN) совершает заданную последовательность шагов, создавая новый слой на основе предыдущего образа.
Т. о. мы имеем последовательно наслаивающиеся друг на друга образы, при котором каждый из них строится на основе конфигурации предыдущего read-only.

Три основных этапа постройки образа:
1. Операционная система:
1.1: FROM image
1.2: RUN команды для настройки ос.
2. Зависимости приложения:
2.1. RUN команды для установки пакетов ос.
2.2. RUN команды для установки модулей и библиотек.
3. Код приложения:
3.1. ADD файлы приложения.
3.2. ENTRYPOINT команда для запуска приложения.

Каждая директива в Dockerfile порождает новый слой в итоговом образе.
Каждый слой образа Read-Only.
В запущенном контейнере при изменении файла внутри образа, он сперва копируется в слой Read-Write и только потом изменяется.

Команды для построения образа:
docker build .
. - указание места, где расположен Dockerfile.
Так же можно указывать иным способом, например:
-f /path/to/dockerfile
-t (tag-name) - задать имя-тег вашего образа.

Наиболее часто встречающиеся нам инструкции:

ENV и ARG - хранят переменные, но переменные ARG не сохраняются в финальном образе, в то время как переменные, указанные в ENV могут применяться во время изолированной работы контейнера.
ARG - хранит данные в формате ключ=значение. Не рекомендуется указывать тут пароли и логины, поскольку эти переменные видны любому пользователю в истории.
Если ENV и ARG имеют ссылаются на идентичные значения, ENV всегда перезаписывает ARG.

.dockerignore - файл, в котором можно перечислить директории и файлы, которые не будут участвовать в постройке образа Dockerfile'a на этапах ADD и COPY.

USER - устанавливает пользователя, под которым выполняются последующие директивы RUN, CMD, ENTRYPOINT.

WORKDIR - указывает рабочую директорию, откуда следует выполнять последующие команды в контейнере.
(RUN, CMD, ENTRYPOINT, COPY, ADD).
От этой директории можно указывать относительный путь в дальнейшем.
WORKDIR можно переопределять несколько раз.
Если WORKDIR не указана, то рабочая директория по умолчанию /.

RUN - RUN исполняет любые команды в новом слое из предыдущего образа и коммитит результаты. Итоговый образ будет использован в следующей инструкции Dockerfile.

CMD - непосредственно команда, которая будет выполняться в контейнере.
Главная цель команды CMD - исполнить указанную здесь команду при запуске рабочего контейнера.
CMD может быть только одна в Dockerfile. Если их несколько, выполняется последняя.

Ещё раз разница между RUN и CMD:
RUN - запускает команды и коммитит их результат для дальнейшего использования в постройке образа.
CMD - не исполняет ничего во время постройки образа, но указывает входящую команду для итогового контейнера.

LABEL - добавляет метаданные формата ключ=значение к образу. Указывается сразу после FROM.

EXPOSE - указывает порт, который контейнер слушает во время работы по умолчанию.

ADD <src> <dest>
ADD - копирует новые файлы, директории или удалённые файлы URL из src в dest контейнера.
dest - нужно писать абсолютный путь, или путь относительно WORKDIR.
Так же при копировании архивов автоматически разархивирует их.

COPY <src> <dest>
COPY - указывает перечень файлов, которые будут копироваться в контейнер.
COPY - в отличие от ADD, может принимать флаг --from=<name>, где <name> - это имя образа с предыдущих стадий создания образа (FROM .. AS <name>),
позволяя, таким образом, копировать файлы из предыдущих этапов создания контейнера, что особенно полезно, если образов несколько.

ENTRYPOINT - позволяет конфигурировать контейнер как исполняемый.
Id est, обычно здесь указывают команду и параметры к ней, которые контейнер принимает к исполнению в момент финального запуска.
Exempli gratia:
ENTRYPOINT ["/bin/app"]
ENTRYPOINT ["sh", "-c"]

Только последнее применение ENTRYPOINT будет активно в итоговом образе.
Все аргументы, перечисленные в командной строке после docker run, перечеркнут определения в CMD (если они есть), но пройдут команду ENTRYPOINT.
Если после ENTRYPOINT есть CMD, то ENTRYPOINT может задавать путь к команде, которая будет использована для CMD. В CMD при этом могут быть дополнительные ключи для команды.

Правила по CMD и ENTRYPOINT.
1. В Dockerfile следует указывать только одну команду CMD и ENTRYPOINT.
2. ENTRYPOINT следует указывать, если контейнер должен быть executable.
3. CMD можно использовать как способ указания базовых аргументов для ENTRYPOINT.
4. При любых аргументах docker run, не относящихся к особенностям запуска контейнера, CMD будет перезаписана.
5. Если при этом в ENTRYPOINT задан запуск приложения, то при попытке запустить контейнер, например, через bash, по умолчанию этого не выйдет, так как любые команды после run image, будут рассматриваться как ключи к ENTRYPOINT. В таких случаях ENTRYPOINT нужно переопределять.

VOLUME - указание места в контейнере, гда хранятся данные, соединённые с данными на хосте.
При этом при запуске контейнера всё равно нужно указывать точку монтирования.
Exempli gratia:
docker run -v /home/my_beatiful_name/my_dir:/mnt/my_dir
d in docker. in docker.irectories my_dir общие и хранят общие файлы.
