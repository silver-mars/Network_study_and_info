# Непрерывный мониторинг

ELK - аббревиатура, используемая для описания стека из трёх популярных проектов: ElasticSearch, Logstash и Kibana.
Стек ELK, зачастую именуемый Elasticsearch, предоставляет возможность собирать журналы всех ваших систем и приложений, анализировать их и создавать визуализации, чтобы мониторить приложения и инфраструктуры, быстрее устранять неполадки, анализировать систему безопасности и многое другое.
**Elasticsearch** - распределённый поисковый и аналитический движок на базе Apache Lucene.
**Logstash** - это предназначенный для приёма данных инструмент с открытым исходным кодом, который позволяет собирать данные из различных источников, преобразовывать их и отправлять в нужное место назначения.
**Kibana** - это инструмент визуализации и изучения данных для просмотра журналов и событий. Kibana предлагает простые в использовании интерактивные диаграммы, встроенные агрегаторы и фильтры, а также геопространственную поддержку, благодаря чему является предпочтительным выбором для визуализации данных, хранящихся в Elasticsearch.

1. Logstash собирает, преобразует и отправляет данные в нужный пункт назначения.
2. Elasticsearch индексирует и анализирует собранные данные и производит поиск в них.
3. Kibana предоставляет визуализацию результатов анализа.

docker-compose.yaml for this decision is here:
https://habr.com/ru/articles/671344/

**Graylog**:
https://habr.com/ru/articles/556194/

# Infrastructura as a code

Подход, при котором инфраструктура описана в виде кода и хранится в СКВ.
Общий язык для команды разработки и команды эксплуатации.
Подпрактика инфраструктуры как код - это **управление версиями**. Это ansible, chief, etc. В них входит:
* Распределённые СКВ
* Интеграция багтрекера и СКВ
* Понятный и автоматизированный процесс создания релиза "по кнопке"
* Code review, pull request и др. хранится в СКВ.

В понятие **микросервисы** входит:
* Децентрализованное управление данными
* Самодостаточность и изолированность
(можем провести smoke-test, запустился, подключился, на холостом ходу ошибок нет)
* Публичное API
* Сервис умеет сам себя обслуживать на основе других сервисов

С точки зрения эксплуатации для того, чтобы получить микросервис, нам нужны:
* Автоматизация инфраструктуры
* Отказоустойчивость
(в них изначально заложена возможность работы с отказом: перезапуск или что-либо иное.
Исходим из парадигмы, что всё может упасть и проектируем с учётом этого (retry-topic'и кафки и т. д. - сюда же).
* Асинхронность
* DDD
(Domain Driven Design?)
* Способность постоянно развивать микросервис

**Достоинства**:
* Возможность использования любых языков и фреймворков
(к каждой задаче можно подобрать наилучший инструмент)
* Небольшие компоненты
* Слабая связность
* Лёгкость обновления
(не нужно обновлять по 4-6 часов как монолиты)

**Недостатки**
* Сложно выкатывать
(не нарушена ли совместимость со всеми остальными задействованными микросервисамиБ?)
* Сложно тестировать
* Распределённая система
* Сложно эксплуатировать
* Несогласованная БД

1:05:30

