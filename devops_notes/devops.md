# Непрерывный мониторинг

ELK - аббревиатура, используемая для описания стека из трёх популярных проектов: ElasticSearch, Logstash и Kibana.
Стек ELK, зачастую именуемый Elasticsearch, предоставляет возможность собирать журналы всех ваших систем и приложений, анализировать их и создавать визуализации, чтобы мониторить приложения и инфраструктуры, быстрее устранять неполадки, анализировать систему безопасности и многое другое.
**Elasticsearch** - распределённый поисковый и аналитический движок на базе Apache Lucene.
**Logstash** - это предназначенный для приёма данных инструмент с открытым исходным кодом, который позволяет собирать данные из различных источников, преобразовывать их и отправлять в нужное место назначения.
**Kibana** - это инструмент визуализации и изучения данных для просмотра журналов и событий. Kibana предлагает простые в использовании интерактивные диаграммы, встроенные агрегаторы и фильтры, а также геопространственную поддержку, благодаря чему является предпочтительным выбором для визуализации данных, хранящихся в Elasticsearch.

1. Logstash собирает, преобразует и отправляет данные в нужный пункт назначения.
2. Elasticsearch индексирует и анализирует собранные данные и производит поиск в них.
3. Kibana предоставляет визуализацию результатов анализа.

docker-compose.yaml for this decision is here:
https://habr.com/ru/articles/671344/

**Graylog**:
https://habr.com/ru/articles/556194/

# Infrastructura as a code

Подход, при котором инфраструктура описана в виде кода и хранится в СКВ.
Общий язык для команды разработки и команды эксплуатации.
Подпрактика инфраструктуры как код - это **управление версиями**. Это ansible, chief, etc. В них входит:
* Распределённые СКВ
* Интеграция багтрекера и СКВ
* Понятный и автоматизированный процесс создания релиза "по кнопке"
* Code review, pull request и др. хранится в СКВ.

В понятие **микросервисы** входит:
* Децентрализованное управление данными
* Самодостаточность и изолированность
(можем провести smoke-test, запустился, подключился, на холостом ходу ошибок нет)
* Публичное API
* Сервис умеет сам себя обслуживать на основе других сервисов

С точки зрения эксплуатации для того, чтобы получить микросервис, нам нужны:
* Автоматизация инфраструктуры
* Отказоустойчивость
(в них изначально заложена возможность работы с отказом: перезапуск или что-либо иное.
Исходим из парадигмы, что всё может упасть и проектируем с учётом этого (retry-topic'и кафки и т. д. - сюда же).
* Асинхронность
* DDD
(Domain Driven Design?)
* Способность постоянно развивать микросервис

**Достоинства**:
* Возможность использования любых языков и фреймворков
(к каждой задаче можно подобрать наилучший инструмент)
* Небольшие компоненты
* Слабая связность
* Лёгкость обновления
(не нужно обновлять по 4-6 часов как монолиты)

**Недостатки**:
* Сложно выкатывать
(не нарушена ли совместимость со всеми остальными задействованными микросервисами?)
* Сложно тестировать
* Распределённая система
* Сложно эксплуатировать
* Несогласованная БД

**Производство цифровых продуктов**.

**Гипотеза**.
**Код** - minimal valuable product - что уже можно выкатить на рынок, чтобы проверить востребован ли этот продукт?
Здесь уже мониторинг, логирование.
**Контроль качества** - форма договора среди команд, каким ПО должно попасть на стадию интеграции.
Что минимально необходимо для перехода в стадию интеграции.
**Интеграция** - коллаборация, chatops - распределённая коллаборация, позволяющая отдельные куски интегрировать вместе.
**Production**.
**Обратная связь**.

# Модель Base, Service, App
Универсальная технологическая модель организации devops.

-----------------------------------------------------
|Layer                              |Responsibility |
-----------------------------------------------------
|Application                        |DevOps         |
-----------------------------------------------------
|Service (IIS, MS SQL, MongoDB)     |Ops            |
-----------------------------------------------------
|Base (Windows, Linux)              |Ops            |
-----------------------------------------------------
**Base** - системные администраторы.
**Сервисный уровень** - это базы данных, хэши, очереди, авторизационные сервисы, хранилища данных.
То, что устанавливается извне как часть платформы и требует обслуживания.
Система для хранения и анализа данных.
Разработчики.

**Четыре базовые devops-компетенции**

* Разработчик с представлением об архитектуре и работе софта в продакшене (пишет тесты и инфраструктурный код)
* Инфраструктурный инженер (пишет обвязки для инфраструктуры, предоставляет разработчику платформу)
(настраивает kubernetes, пишет ansible-playbooks, инфраструктура как код и т. д.)
* Разработчик инфраструктурных сервисов (DBaS, Monitoring as Service, Logging as Service)
* Релиз-менеджер (управляет процессом и зависимостями).

Все 4 компетенции подразумевают владение базовыми практиками.

Для самостоятельного ознакомления:
**Книжка Continious Delivery**

# Система контроля версий. VCS

Нужно для контроля релизов (система версионирования).

Типы систем конроля версий.

* Centralize VCS
Клиент-серверная модель. Разработчику нужно быть на связи с центральным сервером.

* Distributed VCS
У каждого разработчика на локальной машине сохраняется полная версия проекта.
Не нужно общаться с центральным сервером, чтобы скачать себе на машину локальную версию документа, директории или достать другие данные.

**Плюсы DVCS**
* Полноценная локальная копия проекта
* Локальный репозиторий ~ бэкап
В случае падения центрального сервера - если он недоступен - локальная копия разработчика может использоваться для полноценного восстановления.
* Можно работать оффлайн
Работать можно хоть в лесу.
* Скорость
Так как не нужно постоянно устанавливать соединение с центральным сервером.

**Принципы работы GIT'a**

**Хранение изменений**
Любое изменение, любой коммит представляет собой слепок всей структуры репозитория: **snapshot format**.
Любое изменение файла влечёт за собой сохранение нового объекта, содержимое файла сохраняется полностью.
Если файл не изменился, сохраняется ссылка на предыдущую версию файла.

**Сохранение истории** хранится в локальном репозитории в директории .git в корне проекта.
Репозиторий хранит: объекты коммитов, ссылки на коммиты и ветки, конфигурацию и др.

**Как хранятся изменения**
Гит хранит всю информацию в виде объектов и при любом коммите, который мы делаем как минимум создаются три объекта.

4 типа хранимых объектов:
* blob
* tree
* commit
* tag

**blob** - базовая единица хранения данных в Git.
Хранит snapshot (снимок) содержимого файла.

В качестве имени объекта берётся SHA1 хэш содержимого файла и заголовка.

Команда **git cat-file -t file_name** - выводит тип (blob)
Команда **git cat-file -p file_name** - выводит содержимое файла.

# Разобраться с этим самостоятельно подробнее.
# Важно - понять как вообще искать эти типы blob, точно знать где именно они содержатся.

**tree**
Деревья содержат информацию о блобах, а также других поддеревьях.
Деревья решают проблему хранения имён файлов и их группировки по директориям.

blob - хранит содержимое одного файла, он не содержит имени этого файла.
Деревья позволяют хранить структуру репозитория. Они хранят имена файлов: ставят соответствие между именами файлов и соответствующим им блобам.

Таким образом при помощи деревьев и блобов мы можем организовать процесс создания слепка репозитория.

Контентно-адресуемая файловая система.
**Content-addressable storage** (CAS) — архитектура хранения, в которой адресация осуществляется образом хранимых данных.
Образ данных хешируется и хеш используется для его нахождения на устройствах или системах хранения.

**Свойства CAS-устройств**
1. Неизменяемость данных.
Сама архитектура системы гарантирует неизменность хранимой информации. Если какой-либо объект был изменён, то у него будет уже другая контрольная сумма, и это будет уже другой объект, хранимый по другому адресу. При обращении по старому адресу объект будет прочтён в гарантированно первозданном виде, что исключает подмену, подделку и иные подобные действия, что неоценимо в области юриспруденции, безопасности, хранения ключевых доказательств и др.

2. Авторизированное и сертифицированное удаление (Audited delete, Reflections)
Удаление объекта в устройстве не происходит бесследно. Помимо того, что для этого могут потребоваться определённые права доступа, а также авторизация вышестоящего руководства, после удаления объекта остаётся определённая информация о факте удаления, а также о связанных с ним объектах и персонах. Так например устройство позволяет создать хранилище записей камер видеонаблюдения, которое позволяет установить был ли факт наличия/отсутствия определённых записей, а также пользователей, причастных к их удалению. 

3. Единственность копии (Single Instance Storage)
Следствием архитектуры CAS является ещё одна интересная особенность: в случае, если записываются несколько одинаковых файлов, но под разными именами, то реально будет записан только один объект, так как контрольные суммы — и следовательно, адреса размещения всех объектов - совпадут, что значительно экономит дисковое пространство. Однако же при чтении каждый файл будет читаться под своим именем. 

**commit**
Информация о том, кто делает коммит.
Включает в себя:
* Автор, коммитер, дата
* Цифровая подпись
* Сообщение
* Дерево (ссылается на определённое дерево)
* Родитель или родители

**tags**
Два типа:
* Легковесные теги - указатели на определённый коммит
* Аннотированные - содержат имя, email, поставившего тег, дату, комментарий и могут иметь цифровую подпись.
Хранятся как полноценные объекты.

**Git workflow**
1. Начинаем работать в рабочей директории.
Вносим изменения и выбираем их для коммита.
2. Изменения заносятся в Index (Stage) - промежуточная стадия, буферная зона для создания новых коммитов. **git add**
3. Сохраняем изменения в локальный репозиторий .git
4. После этого мы можем поделиться изменениями с другими, например, запушив их в локальный репозиторий.

**Основные команды для работы с git**

1. **git init**
Создать репозиторий в папке с проектом:
git init /path/to/project/folder
git init . # - создать репозиторий в текущей директории
Будет создана папка .git
Теперь можно начать отслеживать историю нашего проекта.

2. **git status**
On branch <...>
**Changes to be committed**:
то, что добавится к коммиту (внесено в индекс).
**Changes not staged for commit**:
не внесено в индекс.
**Untracked files**:
файлы, о которых гит ничего не знает (их раньше не было в локальном репозитории).

**Состояния файлов**
**Untracked** - файл, которого раньше не содержалось в проекте.
**Staged** - файл, который мы добавили в stage, index
**Unmodified** - файл, который был закоммичен.
**Modified** - файл, который был раньше в репозитории, но впоследствии изменился и не был добавлен в index.

3. **git commit --ammend -m "new mesage"** # правка последнего коммита. Добавление/изменение файлов прям в нём и правка прикреплённого к нему message.

4. **git revert** # делает новый (обратный) коммит.
Не меняет истории - безопасный способ откатить изменения. Стоит использовать для публичных коммитов.

5. **git reset HEAD~1** # удаляет коммиты после указанного.
Конкретно данная команда удаляет текущий коммит (из истории в т. ч.) и откатывается на предыдущий.
Так как эта команда меняет историю - это небезопасный способ отката изменений. Можно использовать для локальных коммитов.




