**Базовый слой**
Помимо самого образа виртуальной машины, который мы готовим, агента мониторинга, логирования, системы управления конфигурацией есть инфраструктурный уровень.
Он предоставляет интерфейс к нижележащей инфраструктуре:
это:
* сами механизмы создания виртуальных машин
* настройка дополнительных инфраструктурных компонентов:
* настройка сети
* правила фаерволла
* управление ключами

----------------------------
OS  Backups Monitoring
----------------------------
Infrastructure as a Service
    (Cloud, hardware)
----------------------------

Нижний инфраструктурный уровень позволяет нам запускать, создавать образ виртуальной машины.

На базовом уровне у нас встречаются проблемы:
* ручной процесс, при котором нет контроля над тем, кто и какие изменения вносит в нашу инфраструктуру
* неавтоматизированные настройки и деплой

**Infrastructure as a Code**
* Описание желаемого состояния инфраструктуры в виде кода
* Приведение состояния инфраструктуры в соответствие с описанием
* Готовые прототипы конфигурации
* Применимы практики из разработки:
версионирование, ревью изменений, документирование

**Достоинства**:
* Возможность долгосрочного управления инфраструктурой через код
* Версионирование и контроль изменений
* Самодокументация
* Автоматизация
* Воспроизводимость текущей конфигурации

**Принципы управления инфраструктурой**
* Описывается в виде кода (IaC)
* Любое изменение через код
* Инфра код хранится в VCS
* Повторяемость
* Документация всё равно должна присутствовать
* Командная работа

**Infra репозиторий**
* Содержит описание всей инфраструктуры проекта в виде кода
* Версионирование конфигурации инфраструктуры
* Инфраструктурные изменения производятся через PR (достаточно получить один approve для мёрджа)
* Документация команд и структуры репозитория (README.md)
должна описывать структуру вашего репозитория так, чтобы сторонний человек мог понять как его использовать и какой последовательностью действий запускать
* Повторяемость и переиспользуемость
Важно определять переменные, чтобы сторонний человек так же мог их просмотреть и переиспользовать под свой случай

# Основы работы с Terraform

**Terraform** - это инструмент для декларативного описания инфраструктуры
* Описание инфраструктурных компонентов ведётся на языке HCL
(отличается отсутствием запятых (json-формат) + использованием комментариев)
* Описание инфраструктуры хранится в конфигурационных файлах (имеют расширение .tf)

**Providers**
* Содержат настройки аутентификации и подключения к платформе или сервису
* Предоставляют набор ресурсов для управления
* Являются загружаемыми модулями с версии 0.10.0
* Поддержка большого количества провайдеров: AWS, Google Cloud, GitHub, PostgreSQL, etc.

Установка провайдера производится командой **terraform init**
example: ./provider.tf
provider "google" {
        credentials = "${file("account.json")}"
        project     = "infra-13267"
        region      = "europe-west1"
    }

**Resources**
* Определяются типом провайдера
* Позволяют управлять определёнными инфраструктурными компонентами платформы или сервиса
* Могут иметь обязательные и необязательные аргументы
* Могут ссылаться на другие ресурсы
Комбинация тип ресурса + имя уникально идентифицирует ресурс в рамках данной конфигурации,

Для применения описанной конфигурации и приведения системы в описанное состояние достаточно использовать команду **terraform apply**

**State файлы**
* Terraform хранит информацию об управляемых ресурсах в terraform.tfstate
* terraform.tfstate обновляется при каждом apply или refresh
* terraform.tfstate.backup используется для бэкапа предыдущего terraform.state
* по умолчанию сохраняются локально в папке с конфигурацией

**Планирование изменений**
**terraform plan**
Refreshing Terraform state in-memory prior to plan...
При изменении конфигурации показывает какие изменения произойдут:
что будет:
обновлено ~
добавлено +
удалено -

Хорошая практика перед применением **terraform apply**


**Input переменные**
* Позволяют параметризировать конфигурационные файлы
* Три типа: string, map, list
* Можно передать из файла, из командной строки или интерактивно

Объявление input переменных обычно выносится в один файл, variables.tf
variable project {
    description = "Project ID" # Облегчает работу и понимание кода
}
variable region {
    description = "Region"
    default = "europe-west1"
}

Использование этих переменных в конфигурационных файлах выглядит как:
provider.tf
provider "google" {
    project = "${var.project}"
    region  = "${var.region}"
}

Задание переменных из файла:
terraform apply -var-file=my-vars.rgvars
Если файл называется terraform.tfvars, то переменные загружаются автоматически. (не нужно писать опцию **-var-file**)
Важно добавлять такой файл в .gitignore

**Получение информации об инфраструктуре**
Команда **terraform show** помогает искать нужные атрибуты ресурсов по state файлу.

**output переменные**
* Позволяют сохранить выходные значения после создания ресурсов
* Облегчают процедуру поиска нужных данных
* Используются в модулях как входные переменные для других модулей

**Базовая организация конфигурационных файлов**
* main.tf - основная конфигурация
* variables.tf - объявление input переменных
* outputs.tf - определение выходных переменных
* terraform.tfvars.example



