**Топология сети** - это схема соединения компьютеров в сети.
Представляется в виде графа, где:
Узлы - это вершины (Узлами называют копьютеры и сетевое оборудование).
Рёбра - связь между узлами.

Различают следующие виды топологии:
Полносвязная
Ячеистая (как полносвязная, но некоторые связи удалены)
Звезда (все узлы связаны с центральным устройством)
Кольцо
Дерево
Общая шина
Смешанная топология

# Виды топологии
**Физическая топология** - соединения устройств в сети.
**Логическая топология** - правила распространения сигналов в сети.

Примеры:
классический **Ethernet** имеет физическую топологию **звездв**, поскольку компьютеры подключаются к центральному узлу, но логическую топологию **общая шина**, потому что данные, поступающие на один порт концентратора распространяются на все доступные порты и доступно всем компьютерам в сети.
Коммутируемый **Ethernet** имеет такую же физическую топологию, но логически - **полносвязную**: каждый компьютер может быть соединён напрямую с другим компьютером.
Технология **Wi-Fi** не имеет физическую топологию, а логическую топологию - **общая шина**. Всё, что узел передаёт в радиоэфир доступно всем другим компьютерам, находящимся в зоне действия отправителя.

# Виды стандартов в компьютерных сетях
**De jure** (формальные, юридические) - принятые по формальным законам стандартизации.
Примеры:
ISO (эталонная модель взаимодействия открытых систем),
IEEE (технологии передачи данных, сетевое оборудование),
IAB (протоколы интернет),
W3C (стандарты Web).
Доступны здесь: **https://www.w3.org/standards/**
**De facto** (фактические) - установившиеся сами собой (новые технологии, пользующиеся большой популярностью).

Нас интересует **Internet Engineering Task Force, IETF**, выпускающий стандарты на сетевые протоколы.
он пишет **Request for comments (RFC)** - запросы на комментарии. Содержат в себе:
Документы с описанием работы протоколов
(Формально не называются стандартами (запрос комментариев), но по сути являются таковыми.
Примеры документов:
RFC 791 - протокол IP
RFC 793 - протокол TCP
https://tools.ietf.org/rfc/index

#Основы организации компьютерных сетей

h1. Сложности построения сетей:
Многообразие оборудования и ПО
Надёжность
Развитие сети
Распределение ресурсов
Качество обслуживания
Безопасность

h1. Решение:
Декомпозиция на отдельные подзадачи
Каждый уровень решает одну конкретную задачу или набор связанных задач
Изоляция работ различных уровней

Набор необходимых понятий:
**Сервис** - описывает функционал уровня
**Интерфейс** - набор примитивных операций, которые нижний уровень предоставляет верхнему
Использует реальное взаимодействие внутри компьютера
(Уровень N вызывает уровень N - 1 внутри одного компьютера)
**Протокол** - правила и соглашения, используемые для связи уровня N одного компьютера с уровнем N другого компьютера.
Использует виртуальное взаимодействие между компьютерами
(Реально соединяются друг с другом только уровни, работающие с физической средой)
Виртуальное взаимодействие происходит через заголовки протокола.

**Кратко:**<br>
Сервис - что делает уровень.<br>
Протокол - как уровень это делает.<br>
Интерфейс - как получить доступ к сервису уровня.<br>

**Архитектура сети**:
задаёт набор уровней и протоколов сети.
(Интерфейсы в архитектуру не входят, т. к. могут быть разные на разных программно-аппаратных платформах)

**Стек протоколов** - это иерархически организованный набор протоколов, достаточный для организации взаимодействия по сети.

**Инкапсуляция** - включение сообщения вышестоящего уровня в сообщение нижестоящего уровня.
Сообщение строится по типу: заголовок + данные + концевик (необязательный).

#Модель OSI
Это одна из эталонных моделей организации сети, решающая вопросы:
* Какие уровни долдны быть в сети?
* Какие функции должны выполняться на каждом уровне?

Модель OSI расшифровывается как Open System Interconnection (Модель взаимодействия открытых систем).

**Открытая система** - система, построенная в соответствии с открытыми спецификациями.
**Открытая спецификация** - общедоступная спецификация, соответствующая стандартам.

**Преимущества открытых систем**
* Возможность строить сети из оборудования разных производителей
* "Безболезненная" замена отдельных компонентов сети
* Лёгкость объединения нескольких сетей

Модель OSI используется в качестве "общего языка" для описания разных сетей
Включает 7 уровней организации сети и их назначение
(Протоколы не включены в модель)

<details>
    <summary>Уровни:</summary>
**Application**
Набор приложений
Единица передаваемых данных:
Сообщение
**Presentation**
Предоставлять данные в том виде, который понятен и отправителю, и получателю.
Обеспечивает согласование синтаксиса и семантики передаваемых данных.
* Форматы представления символов
* Форматы чисел
Шифрование и дешифрование
Examples: TLS, SSL
Единица передаваемых данных:
Сообщение
**Session**
Позволяет устанавливать сеансы связи
Задачи:
Управление диалогом (определяет очерёдность передачи сообщений)
Управление маркерами (предотвращение одновременного выполнения критичной операции, транзакции)
Синхронизация (защита от разрыва сетевого соединения и возможность возобновления передачи при восстановлении соединения)
Единица передаваемых данных:
Сообщение
**Transport**
Обеспечивает передачу данных между процессами на хостах
Единица передаваемых данных:
Сегмент/Дейтаграмма
**Network**
Объединяет сети, построенные на основе разных технологий
Задачи:
создание составной сети
Адресация,
**Маршрутизация** - определение маршрута пересылки пакетов в составной сети.
Единица передаваемых данных:
Пакет
**Data Link**
Передача сообщений: определение начала/конца сообщения в потоке бит
Физическая адресация
Единица передаваемых данных:
Кадр
**Physical**
передача битов по физическому каналу связи
Задача: представление бит информации в виде сигналов, передаваемых по среде
Единица передаваемых данных:
Бит
</details>

На разных уровнях модели OSI работает разное оборудование:
Сетевой - Маршрутизатор
Канальный - Коммутатор, точка доступа
Физический - Концентратор

#Модель TCP/IP
Фактический стандарт (de facto).

Прикладной
Транспортный
Интернет
Сетевых интерфейсов

Есть разновидность, известная как "Пятиуровневая модель OSI + TCP/IP":
Прикладной
Транспортный
Сетевой
Канальный
Физический

Описана у Таненбаума, Уэзеролла в книге "Компьютерные сети".
Считается что эта модель ближе всего к тому, что сейчас используется на практике.

#Физический уровень
**Сервис** - передача потока бит по среде передачи данных.
Не вникает в смысл передаваемой информации.
Единица передачи информации - бит.
**Основная задача** - зпредставить биты информации в виде сигналов, передаваемых по среде.
Различают следующие **характеристики канала связи**:
* **Пропускная способность** (бит/с)
* **Задержка** - за сколько времени сообщение доходит от отправителя до получателя
Совместно пропускная способность и задержка характеризуют **скорость работы канала**.
* **Количество ошибок**

**Типы каналов связи**:
* **Симплексный** - данные можно передавать только в одну сторону
* **Дуплексный** - данные можно передавать в обе стороны
* **Полудуплексный** - данные также можно передавать в обе стороны, но по очереди

**Среды передачи данных**
* Кабель:
Витая пара
Оптоволокно
Провода электропитания 220В и т. д.
* Беспроводные технологии:
Радиоволны
Инфракрасное излучение
* Спутниковые каналы
* Беспроводная оптика (лазеры)

**Особенности беспроводной сети**:
* Сигнал передаётся по нескольким направлениям
* Один и тот же сигнал могут принимать несколько приёмников
* Несколько источников сигнала искажают друг друга и требуют координации работы

Поэтому используемые диапазоны регулируются законодательством:
Пример:
Сотовая связь (GSM) - 900 МГц
Wi-Fi: 2,4 ГГц и 5 ГГц
Но другие приборы также работают на этой частоте. Поэтому роутер, расположенный рядом с микроволновкой - не очень хорошая идея.

Среда передачи данных   Частота возникновения ошибок
Оптические кабели       Очень редко
Медные кабели           Редко
Радиоволны              Часто

**Представление информации** также различается:
В медных проводах используется **кодирование**, т. н. прямоугольные импульсы
0 - отсутствие напряжения, 1 - напряжение, но на практике используются более сложные схемы.
**baseband modulation**

В оптоволокне и беспроводной среде используется **модуляция**, т. н. синусоидальные волны
**passband modulation**

#Физический уровень
**Основная задача** - передача сообщений по каналам связи - кадров (frame)
Также на этом уровне:
* определяется точка начала/конца кадра в потоке бит
* происходит обнаружение и коррекция ошибок

Если на канале связи есть несколько устройств, то здесь также решаются следующие вопросы:
* Адресация
* Согласованный доступ к каналу

Канальный уровень получает с сетевого уровня пакет данных.
Затем он добавляет к нему **Заголовок** и **Концевик**, формируя из пакета таким образом **кадр**.
Затем данное сообщение передаётся по среде передачи данных и поступает на канальный уровень принимающего хоста.
В результате на канальном уровне принимающего хоста расшифровываются Заголовок и Концевик и извлечённый **пакет данных** передаётся выше на сетевой уровень.

##Методы выделения кадров##

**Указатель количества байт**

Например, самый простой способ указать начало и конец кадра: в начале каждого кадра указывать его длину в байтах.
Другой метод - вставка в начало и конец каждого кадра особой последовательности байтов или бит, например:
**Протокол BSC** использует текстовые символы:
* DLE STX - начало кадра (Start of TeXt)
* DLE ETX - конец кадра (End of TeXt)
* Escape последовательность в данных - DLE (Data Link Escape)
**Протоколы HDLC и PPP** используют биты:
* 01111110 - начало и каонец кадра
* В данных после пяти последовательных единиц добавлялся 0 для избежания случайного совпадения в теле сообщения вышеупомянутой комбинации бит
* Получатель, в свою очередь после пяти последовательных единиц игнорировал 0

**bit/byte stuffing** (вставка битов/байтов)

**Средства физического уровня**
Преамбула (классический Ethernet)
* Длина 8 байт
* Первые 7 байт: 10101010
* Последний байт: 10101011 (ограничитель начала кадра)

Передача неиспользуемых символов избыточного кода (Fast Ethernet)
* Начало кадра - пара символы J (11000) и K (10001)
* Конец кадра - символ T (01101)

##Варианты обнаружения и исправления ошибок##
**Обнаружение ошибок:**
* Контрольная сумма
Самый простой способ - просто отбросить кадр с нарушенной контрольной суммой

**Исправление ошибок**
* Коды исправляющие ошибки (с избыточной информацией)
* Позволяют обнаруживать и исправлять ошибки

**Повторная отправка данных**
* Если в кадре обнаружена ошибка, его можно отправить заново
Используется совместно с обнаружением ошибок.
* Повторная отправка кадра, который не дошёл до получателя

Есть два варианта метода повторной отправки:
**Остановка и ожидание**
* Отправитель передаёт кадр и останавливает передачу
* Получатель отправляет подтверждение
* Отправитель передаёт новый кадр
У отправителя есть таймаут, если за время ожидания таймаут истёк и подтверждения не пришло - необходимо отправить кадр повторно.
Такая технология используется в Wi-Fi.

**Скользящее окно**
* Отправитель передаёт несколько кадров один за другим, не дожидаясь подтверждения
* Количество кадров, которое можно отправить, называется **размером окна**
* Получатель подтверждает получение кадров (для последнего полученного сообщения)
* Отправитель передаёт новую порцию кадров
(Используется на транспортном уровне в протоколе TCP)

На практике обнаруживать, исправлять ошибки и осуществлять повторную отправку данных можно на разных уровнях:
* Каналы связи с редкими ошибками (например, кабель, волокно) - на верхних уровнях
* Каналы связи с частыми ошибками (например Wi-Fi) - на канальном уровне

Модель OSI разрабатывалась для каналов связи точка-точка
(последовательные линии связи для соединения больших компьютеров)

Когда получили распространение разделяемые каналы связи, модель пришлось изменить.

Канальный уровень был разделён на два подуровня:

**Подуровень управления логическим каналом (Logical Linc Control, LLC)**
* Отвечает за передачу данных (создание кадров, обработка ошибок и т. д.)
* Общий для разных технологий

**Подуровень управления доступом к среде (Media Access Control, MAC)**
* Совместное использование разделяемой среды
* Адресация
* Специфичный для разных технологий
* Не является обязательным (для формата точка-точка, например)

Также подуровень LLC способен осуществлять:
**Мультиплексирование**
* Передача данных разных протоколов (IP, ARP, ICMP) на уровень MAC (через канальный уровень)

**Управление потоком:**
* Предотвращение "затопления" медленного получателя быстрым отправителем
(Если в сети устройства, работающие с разной скоростью, возможна ситуация, когда более быстрое и мощное устройство начинает передавать огромный и быстрый объём данных медленному получателю, "затапливая" его.

##Согласованный доступ к разделяемому каналу связи##

**Управление доступом**:
* Обеспечение использования канала только одним отправителем в один и тот же момент времени
в противном случае произойдёт **коллизия** (данные искажаются, если несколько компьютеров передают одновременно)

**Методы управления доступом**:
* Рандомизированный - из N компьютеров выбирается один с вероятностью 1/N. (Ethernet, Wi-Fi)
* На основе правил использования. (Token Ring)

#Ethernet#
Две технологии Ethernet:

**Классический Ethernet**
* Разделяемая среда
* Ethernet - Gigabit Ethernet

<details>
    <summary>Уровни:</summary>
Ethernet            10 MB/s     802.3
Fast Ethernet       100 MB/s    802.3u
Gigabit Ethernet    1 Gb/s      802.3z, 802.3ab
</details>

**Коммутируемый Ethernet**
* Точка-точка
* Появился в Fast Ethernet
* Единственный вариант в 10G Ethernet и выше

Почти всё современное оборудование поддерживает обе технологии.

##Классический Ethernet##
Исторически - самый первый.
Общая шина - коаксиальный кабель
К каждому компьютеру подключался т-коннектор, соединяющий его с общей шиной.
Минусы - разрыв в одном месте приводил к повреждению всей сети в целом.

Следующий этап технологии - **hub** или **концентратор**
Устройство для создания сетей Ethernet на основе **витой пары**

Физическая топология - **звезда**.
Логическая топология - **общая шина**, так как сигнал, поступающий на один порт концентратора передаётся на все остальные порты.

Преимущества:
если выйдет из строя кабель или сетевой адаптер - сеть перестаёт работать только на одном компьютере.
На основе цветовой индикации легко найти источник, где нет линка.

**Физический уровень Ethernet**
Технология Ethernet содержит описание передачи сигналов по трём разным типам кабелей:
* Коаксиальный
* Витая пара
* Оптоволокно

**Канальный уровень Ethernet**
* Методы доступа и протоколы, одинаковые для любой среды передачи данных
* В классическом Ethernet смешаны подуровни LLC и MAC

На канальном уровне для передачи данных используются кадры.
Есть три стандарта реализации кадра:
* Экспериментальная реализация Ethernet в Xerox (сейчас почти не используется)
* Ethernet II (Ethernet DIX) - фирменный стандарт Ethernet компаний DEC, Intel, Xerox
* IEEE 802.3 - юридический стандарт Ethernet

Стандарты Ethernet II и IEEE 802.3 незначительно отличаются друг от друга
* Ethernet II используется чаще.

#Формат кадра Ethernet
6 байт      6 байт      2 байта     46-1500 байт    4 байта
Адрес       Адрес       Тип         Данные          Контрольная сумма
получателя  отправителя документа
                        0800 - IPv4
                        86DD - IPv6
                        0806 - ARP
                        etc
Header      Header      Header      Body            Концевик

Поле данные от протокола верхнего уровня:
Максимальная длина 1500 байт,
* Выбрана разработчиками Ethernet
* Ограничение на размер памяти для буфера
* Существует расширение JumboFrame (до 9000 байт)

Минимальная длина 46 байт
* Ограничение технологии Ethernet

#MAC адреса.
Используется на подуровне канального уровня: Media Access Control
Регламентированы стандартом IEEE 802
Наиболее популярны:
Ethernet    (IEEE 802.3)
Wi-Fi       (IEEE 802.11)
**Длина MAC-адреса**
6 байт (48 бит)
**Форма записи** - шесть шестнадцатеричных чисел:
примеры:
* 1C-75-08-D2-49-45
* 1C:75:08:D2:49:45

**Типы MAC-адресов**Ж
1. Индивидуальный (unicast):
* 30-9C-23-15-E8-8C
2. Групповой (multicast, первый бит старшего байта адреса равен 1):
* 01-80-C2-00-00-08
(Передача осуществляется на группу устройств. На этих устройствах должен быть настроен multicast).
3. Широковещательный (broadcast, все 1):
* FF-FF-FF-FF-FF-FF

**Уникальность MAC-адресов**
В одном сегменте сети не должно быть одинаковых MAC-адресов.
* Одна широковещательная среда Ethernet или Wi-Fi
* Один VLAN в коммутируемом Ethernet

Если будет два компьютера с одним MAC-адресом, то один из них не будет работать
* Какой именно не регламентируется

**Способы назначения адресов**
1. Централизованный (по умолчанию) - производителем оборудования согласно стандартам IEEE 802.
2. Локальный - администратором сети, администратор обеспечивает уникальность.

Индикатор способа назначения - второй бит старшего байта MAC-адреса:
- 0 - адрес назначен централизованно
- 1 - адрес назначен локально

Структура централизованного MAC-адреса:
* Первые 3 байта - уникальный идентификатор организации (Organizationally Unique Identifier, OUI), выдаются производителям оборудования.
Примеры:
* 00:00:0C - Cisco
* 00:02:B3 - Intel
* 00:04:AC - IBM
* Последние 3 байта - назначает производитель оборудования, который отвечает за уникальность.

#Классический Ethernet. Метод CSMA/CD.
**Управление доступом к среде** реализуется посредством обеспечения использования канала только одним отправителем.

Классический Ethernet использует для этого метод CSMA/CD:
* Carrier Sense Multiple Access with Collision Detection
* Множественный доступ с прослушиванием несущей частоты и обнаружением коллизий
**Carrier Sense**
Для избежания коллизий, компьютеры передают данные только если среда свободна.
Способ определить, свободна ли среда - прослушивание основной гармоники сигнала (несущей частоты).
**Несущая частота** - основная гармоника сигнала, зависящая от среды передачи данных и используемого протокола передачи данных.
Например, смена тактовой частоты в середине каждого такта при манчестерском кодировании означает, что передача данных уже идёт.
Также может быть случай, когда тактовой частоты нет, но какой-то сигнал есть - это означает что это не сигнал передачи данных, а просто помехи.

**Collision Detection**
Если два компьютера начали передачу одновременно - происходит коллизия.

**Обнаружение коллизий:**
* Компьютер передаёт и принимает сигналы одновременно.
* Если принятый сигнал отличается от переданного - значит возникла коллизия.

Jam-последовательность - передаётся компьютером при обнаружении коллизии для того, чтобы другие компьютеры легче её распознали.
Jam-последовательность - это сигнал, который существенным образом искажает все передаваемые по сети данные, усиливая коллизию чтобы все компьютеры в разделяемой среде поняли, что произошла коллизия и остановили передачу.

В модели CSMA/CD при передаче кадра есть три периода:
1. Период передачи - один из компьютеров передаёт данные в разделяемой среде.
2. Период конкуренции - возникает, когда несколько компьютеров пытаются начать передавать данные.
3. Период простоя - никому данные передавать не нужно, среда свободна.
**Период передачи:**
Если в среде нет несущей частоты, то компьютер может начинать передачу данных.
**Схема передачи:**
Преамбула, Кадр, Межкадровый интервал

**Преамбула** позволяет отправителю и получателю синхронизироваться.
Длина 8 байт
Первые 7 байт: 10101010 - за счёт этого обеспечивается синхронизация отправителя и получателя
Последний байт: 10101011 - две последние единицы - ограничитель начала кадра - знак, что преамбула закончилась.
**Передача кадра**
В классическом Ethernet после окончания преамбулы компьютер начинает передавать кадр.
Все остальные компьютеры в сети начинают принимать кадр и записывают его в свой буфер.
Первые 6 байт кадра содержат адрес получателя:
* Компьютер, который узнал свой адрес, продолжает записывать кадр
* Остальные удаляют кадр из буфера
Есть специальный режим адаптера:
**Неразборчивый режим** (promiscuous mode):
* Адаптер принимает все кадры в сети, независимо от MAC-адреса назначения.
Часто используют для диагностики сети.
**Межкадровый интервал**:
После передачи кадра в классическом Ethernet выдерживается интервал в 9,6 мкс (микросекунд).
Это делается для предотвращения монопольного захвата канала каким-либо одним устройством
и для приведения сетевых адаптеров в исходное состояние и подготовки их к дальнейшим операциями принятия и передачи кадра.

После межкадрового интервала другие компьютеры могут начать конкурировать за передачу: происходит период конкуренции.

В период конкуренции, если компьютер начал передавать данные и обнаружил коллизию, то он делает паузу.
**Длительность паузы:** L * 512 битовых интервалов.
**Битовый интервал** - это время между появлениями двух последовательных битов данных (0,1 мкс в классическом Ethernet)
L случайно выбирается из диапазона [0, 2 в степени N - 1, где N - номер попытки.

Такой алгоритм называется **экспоненциальным** двоичным алгоритмом отсрочки.
Экспоненциальный, поскольку 2 растёт по экспоненте.
Диапазоны L:
* 1 попытка: [0, 1]
* 2 попытка: [0, 3]
* 3 попытка: [0, 7]
* 5 попытка: [0, 31]
* 10 попытка: [0, 1023]
После 10 попыток интервал не увеличивается
После 16 попыток передача прекращается

Экспоненциальный двоичный алгоритм отсрочки хорошо работает при низкой загрузке:
* Когда в сети мало компьютеров
* Когда компьютеры редко передают данные

Если нагрузка высокая, то коллизии возникают чаще:
* Растёт число попыток передачи
* Растёт интервал, из которого выбирается L, и длительность пауз
* Экспоненциально увеличивается задержка
В результате скорость передачи данных по сети существенно снижается.

**Недостатки классического Ethernet**
Плохая масштабируемость:
* Сеть становится неработоспособной при загрузке разделяемой среды больше, чем на 30%
* Работоспособное количество компьютеров - 30

Низкая безопасность:
* Данные в разделяемой среде доступны всем

Разное время доставки кадра:
* Причина - коллизии
* Плохо для трафика реального времени

Решение проблем:
* Коммутируемый Ethernet

**Типы Ethernet**
Классический Ethernet
Исторически появился первый (1973 г.)
Разделяемая среда, коллизии
Метод CSMA/CD

Коммутируемый Ethernet
Новая усовершенствованная технология (1995 г., Fast Ethernet, IEEE 802.3u)
Нет разделяемой среды
Нет коллизий
Новые устройства - коммутаторы (switch)

**Концентратор (Hub)**
имеет топологию - общая шина.
Все порты внутри соединены друг с другом.
Работает на физическом уровне:
передаёт поступающие ему электрические сигналы на все остальные порты.

**Коммутатор (Switch)**
Имеет полносвязную топологию.
Все порты соединены друг с другом на прямую по технологии "точка-точка".
Работает на канальном уровне:
анализирует заголовок канального уровня, извлекает из него адрес получателя и передаёт данные только на тот порт, к которому подключен получатель.

#Особенности работы коммутаторов
**Таблица коммутации**
* Соответствие MAC-адресов портам коммутатора

Для заполнения таблицы MAC-адресов используется
**Алгоритм обратного обучения**
* Заполнение таблицы коммутации

После того, как таблица заполнена для передачи данных используется
**Алгоритм прозрачного моста**
* Передача кадров коммутатором

**Таблица коммутации**
Содержит данные о доступности MAC-адресов через порты коммутатора.
Пример:
Порт коммутатора    MAC-адрес
        1           1C-75-08-D2-49-45
        2           00-02-B3-A7-49-D1
        3           00-04-AC-85-E7-03
В реальности таблица устроена более сложно (тип записи, номер vlan, состояние порта и т. п.)

**Алгоритм обратного обучения**
Коммутатор принимает все кадры, которые приходят на его порты,
извлекает из них заголовок канального уровня,
а оттуда - адрес отправителя.
Т. о. он записывает этот адрес в соответствие с тем портом, откуда он его извлёк.
Так происходит до тех пор, пока коммутатор не заполнит данные обо всех подключенных к его портам устройствах.

**Сетевой мост**
**Мост** - это устройство для объединения нескольких сетей.
Мосты в классическом Ethernet использовались для разделения крупных сетей на несколько маленьких сетей, внутри которых коллизий возникало гораздо меньше.
Мост принимал все кадры из пограничных сетей, но передавал их в другую сеть только если они предназначались для компьютера из другой сети.
* Предшественник коммутатора
Для коммутатора был выбран алгоритм прозрачного моста
**Прозрачный мост**:
* Не заметен для сетевых устройств (нет своего MAC-адреса)
* Не требует настройки
В таком режиме работает коммутатор: является мостом с большим количеством портов, не требует настройки.

**Алгоритм прозрачного моста**
Когда таблица коммутации заполнена, коммутатор принимает кадры, анализирует заголовок канального уровня и извлекает оттуда адрес получателя.
Ищет этот адрес в таблице коммутации и передаёт его в соответствующий адресу порт.

Если пришёл кадр с адресом получателя, которого нет в таблице MAC-адресов, то коммутатор работает как концентратор:
передаёт кадр на все порты, кроме того, откуда он поступил.

Если используется сеть, состоящая только из коммутаторов, то в такой сети коллизии не возникают
Исключения составляют полудуплексные соединения компьютеров к коммутатору. Коллизия может возникнуть, если компьютер и коммутатор одновременно решат передавать данные.

Если к порту коммутатора подключен концентратор, то этот порт подключается к общей разделяемой среде и на нём могут возникать коллизии как в классическом Ethernet.

**Особенности работы коммутаторов**
* Анализируют заголовок канального уровня
* Передают кадр только получателю
* "Изучают" сеть (алгоритм обратного обучения, таблица коммутации)

**Преимущества**
* Высокая производительность и масштабируемость
* Высокая безопасность

#VLAN

Virtual local area network (виртуальная локальная сеть)
Технология разделения единой физической сети на несколько логических сетей, изолированных друг от друга
**Место в модели OSI**
* Канальный уровень
* Коммутаторы

Использование VLAN необходимо для
**изоляции сетей**
* Разные отделы внутри крупной компании
* Разные компании в бизнес-центре и т. д.

**Преимущества изоляции сетей**
* Безопасность
* Распределение нагрузки
* Ограничение широковещательного трафика

В коммутаторах порты часто различаются разными цветами, чтобы различать VLAN, к которому они принадлежат.

Реализация в таблице коммутации - добавление нового атрибута **идентификатор VLAN**:

Порт коммутатора    MAC-адрес           VLAN
        1           1C-75-08-D2-49-45   2
        2           00-02-B3-A7-49-D1   3
        3           00-04-AC-85-E7-03   2
        4           54-BE-F7-88-15-47   3

Даже если компьютер отправителя знает MAC-адрес получателя, коммутатор не передаст данные, поскольку передача запрещена.

При передаче информации от одного коммутатора к другому возникла необходимость передавать в кадре идентификатор VLAN'a, но в классическом кадре места под это нет:

6 байт      6 байт      2 байта     46-1500 байт    4 байта
Адрес       Адрес       Тип         Данные          Контрольная сумма
получателя  отправителя документа
                        0800 - IPv4
                        86DD - IPv6
                        0806 - ARP
                        etc
Header      Header      Header      Body            Концевик

Решение было предложено в стандарте IEEE 802.1Q

6 байт      6 байт      2 байта         2 байта     2 байта     46-1500 байт    4 байта
Адрес       Адрес       Тип             Тег         Тип         Данные          Контрольная сумма
получателя  отправителя стандартного    содержит    код
                        кадра           номер       протокола
                        0x8100 -        VLAN        уровня
                        указатель,                  выше
                        что кадр с
                        VLAN
Header      Header      Header          Body        Body        Body            Концевик

До внедрения этой технологии информация о номере VLAN'a добавлялась и использовалась только коммутаторами.

Реализация стандарта IEEE 802.1Q выглядит следующим образом:
Сетевой адаптер в компьютере генерирует обычный Ethernet-кадр, внутри которого обычный IP-пакет. В поле Тип протокола следующего уровня содержится значение 0x0800.
Коммутатор получает этот кадр, понимает, что он был получен с компьютера, входящего в определённый VLAN.
Коммутатор добавляет служебные поля:
В поле "Тип протокола следующего уровня" 0x800 заменяется на 0x8100,
добавляется тег с идентификатором VLAN'a,
и затем записывается код протокола следующего уровня: 0x0800

Принимающий коммутатор видит тег с идентификатором VLAN'a,
удаляет информацию о номере VLAN и восстанавливает старые значения о протоколе следующего уровня,
пересылает кадр принимающему компьютеру.

**Типы VLAN**
* Нетегированные - номер VLAN в таблице коммутации
Используется внутри одного коммутатора
* Тегированные - номер VLAN в кадре (стандарт IEEE 802.1Q)
Используются если сеть состоит из нескольких коммутаторов

#STP Protocol
При кольцевом соединении коммутаторов возникает широковещательный шторм.

**Протокол связующего (остовного) дерева**
(Spanning Tree Protocol, STP)
позволяет автоматически отключать дублирующие соединения в Ethernet, чтобы в сети не образовалось кольца и широковещательного шторма.
* Связующее (остовное) дерево - подграф без циклов, содержащий все вершины исходного графа.

Протокол STP определен в стандарте IEEE 802.1D

**Преимущества STP**
* Надёжность соединений между коммутаторами.
* Защита от ошибок конфигурации.
Защищает от случайного подключения коммутаторов в кольцевое соединение:
Соединение будет отключено на программном уровне.

**Этапы работы протокола**
Протокол STP работает в 3 этапа:
1. Выбор корневого коммутатора
2. Определение кратчайших путей до корневого коммутатора
3. Отключение всех остальных соединений

Для реализация STP коммутаторы каждые 2 секунды отправляют управляющие сообщения Bridge Protocol Data Units (BPDU) на групповой адрес STP:
* 01:80:C2:00:00:00.

**Выбор корневого коммутатора**
Выбор происходит по идентификатору коммутатора: выбирается минимальный.
По умолчанию в качестве идентификатора используется MAC-адрес коммутатора.
Но можно повлиять на выбор вручную, чтобы выбрать в качестве корневого коммутатора самый мощный.

На первом этапе коммутаторы не знают друг о друге и каждый считает себя корневым и рассылает всем связанным коммутаторам сообщение о том, что он - корневой коммутатор.
Получив сообщения от своих соседей, коммутаторы сравнивают BID в сообщении со своим BID (Bridge ID).
На следующем этапе коммутаторы будут рассылать сообщение не со своим BID, а с BID коммутатора, которого они признали корневым.

**Расчёт кратчайших путей**
После выбора корневого коммутатора, все остальные рассчитывают кратчайшие пути до него

Длина пути между коммутаторами определяется двумя параметрами:
* Количество промежуточных коммутаторов
* Скорость соединений

Коммутаторы рассылают на все порты BPDU с минимальным расстоянием до корневого коммутатора:
Предположим, что соединение между коммутаторами 1 Gbit/s. Тогда расстояние между ними согласно стандарту равно четырём:

Скорость соединения     Стоимость соединения в STP IEEE 802.1D
    4 Mbit/s                            250
    10 Mbit/s                           100
    16 Mbit/s                           62
    100 Mbit/s                          19
    1 Gbit/s                            4
    2 Gbit/s                            3
    10 Gbit/s                           2

1. Коммутаторы, непосредственно подключённые к корневому коммутатору, определяют скорость соединения с этим коммутатором и выбирают соответствующее значение расстояния.
2. Затем это кратчайшее расстояние рассылается следующим непосредственно подключённым коммутаторам.
3. Они берут это значение, определяют скорость соединения с коммутаторами, передавшими им это значение и определяют суммарное расстояние.
Так мы узнаём расстояние от всех портов до корневого коммутатора.

**Отключение лишних соединений**
Если есть кольцевое соединение, то одно из соединений отключается на этом этапе по следующей логике:
отключается либо соединение, имеющее наибольшее расстояние,
либо отключается тот порт, который имеет наибольшее значение порта.

В этот момент образуется связующее дерево, циклов нет.
При этом если одно из соединений разорвётся, то выключенное соединение снова начнёт работать, как имеющее наименьшее расстояние.

Если мы используем протокол STP, то при подключении устройства к коммутатору нельзя сразу же начинать передавать данные, потому что на новом соединении может оказаться коммутатор и отправка сообщения может привести к созданию кольца и широковещательному шторму.
Для того, чтобы избежать этого, в протоколе STP используются несколько режимов работы портов.

**Состояние портов в STP**
**Listening** - порт обрабатывает BPDU, но не передаёт данные. Начальная стадия подключения.
**Learning** - порт не передаёт кадры, но изучает MAC-адреса в поступающих кадрах и формирует таблицу коммутации. Это второй этап.
**Forwarding** - порт принимает и передаёт кадры данных и BPDU.
**Blocking** - порт заблокирован на программном уровне, чтобы избежать кольцевого соединения.
**Disabled** - порт выключен администратором.

Переход от состояния Listening до Forwarding занимал около 30 секунд в 80-ых годах.
Достаточно долго для современных крупных и часто меняющихся сетей.

**Расширения протокола STP**
RSTP (Rapid Spanning Tree Protocol):
* Улучшенная версия STP
* Срабатывает быстрее при подключении оборудования и изменении конфигурации сети
* Стандарт IEEE 802.1w

**STP и VLAN**
По умолчанию протокол STP не учитывает технологию VLAN:
вы можете создать несколько соединений между коммутаторами, которые будут принадлежать разным VLAN'ам, но Spanning Tree в исходном варианте ничего не знает про VLAN'ы, поэтому часть соединений будет отключена.
Для того, чтобы использовать протокол Spanning Tree с технологией VLAN, необходимо, чтобы остовное дерево строилось для каждого VLAN'a отдельно.
Эту возможность реализовали в стандарте IEEE 802.1s:
* Multiple Spanning Tree Protocol (MSTP), IEEE 802.1s
* Отдельное связующее дерево для каждого VLAN

#Wi-Fi
Wi-Fi - доминирующая технология беспроводной передачи данных в локальных сетях.
Торговая марка, принадлежит компании Wi-Fi Alliance.
Технология Wi-Fi описана в стандартах серии IEEE 802.11.

Ранний вариант расшифровки:
"Wireless Fidelity" - беспроводная точность.
Но сейчас считается, что это игра слов с Hi-Fi - высокая точность.

Для того, чтобы производитель мог назвать своё оборудование Wi-Fi, он должен сдать его на проверку в компанию Wi-Fi Alliance.
Wi-Fi Alliance проверяет оборудование на совместимость со стандартом.
* Только после проверки можно использовать символ Wi-Fi
* Для Ethernet такая проверка не производится.

В модели OSI Wi-Fi находится на физическом и канальном уровне.
В канальном уровне используются два подуровня (Logical Link Control, Media Access Control)

Wi-Fi может работать в двух режимах:
* Инфраструктурный
Характеризуется наличием беспроводного оборудования, т. н. точки доступа, которые подключаются к проводной сети и затем к интернету.
* Одноранговая сеть
Компьютеры взаимодействуют без точек доступа напрямую друг с другом.

**Технология Wi-Fi очень похожа на Ethernet**

Можно сказать, что это Ethernet, адаптированный к беспроводной среде:
Адресация:
* MAC-адреса.
Для передачи данных разделяемая среда:
* Радиоэфир.
И у Wi-Fi и у Ethernet общий формат кадра уровня LLC:
* Стандарт IEEE 802.2
Хотя в процессе передачи по беспроводной среде на уровне MAC Wi-Fi используется другой формат кадра.

**Стандарты физического уровня Wi-Fi**
Название            Год принятия    Скорость        Частота
802.11                  1997           1 и 2 Мб/с   2,4 ГГц
802.11a                 1999           54 Мб/с      5 ГГц
802.11b                 1999           11 Мб/с      2,4 ГГц
802.11g                 2003           54 Мб/с      2,4 ГГц
802.11n                 2009           600 Мб/с     2,4 и 5 ГГц
                                       150 Мб/с одна станция
802.11ac                2014           6.77 Гб/с    5 ГГц
                                       1.69 Гб/с одна станция

Wi-Fi использует для передачи данных электромагнитное излучение и радиоэфир:
2,4 ГГц – 802.11, 802.11b, 802.11g, 802.11n
5 ГГц – 802.11a, 802.11n, 802.11ac
Но в первом стандарте 802.11 использовалось инфракрасное излучение.

Диапазон 2,4 и 5 ГГц не требуют лицензирования:
* Можно использовать свободно
* Другие устройства также используют этот диапазон и создают помехи

**Современные стандарты Wi-Fi используют метод OFMD**
Orthogonal Frequency Division Multiplexing (мультиплексирование с ортогональным частотным разделением).

При этом данные передаются параллельно на разных частотах.
В диапазоне 2.4 ГГц для передачи данных используется 14 каналов.
Их частоты:
Канал   Частота (ГГц)
1           2.412
2           2.417
3           2.422
4           2.427
5           2.432
6           2.437
7           2.442
8           2.447
9           2.452
10          2.457
11          2.462
12          2.467
13          2.472
14          2.484

Каналы немного сдвинуты друг относительно друга, но всё равно частично перекрываются.
Таким образом количество Wi-Fi сетей, которые находятся в одном и том же месте, ограничены количеством каналов.
Если в одной и той же области будет работать больше, чем 14 сетей, им не хватит каналов.
Такая ситуация известна как **"Wi-Fi джунгли"** и она довольно часто встречается, например, в жилых домах.

Wi-Fi может использовать каналы разной ширины: 20, 40, 80 или 160 МГц.
* 20 МГц - первые стандарты Wi-Fi
* 40 МГц - 802.11n
* 80 МГц - 802.11ac (поддержка обязательна)
* 160 МГц - 802.11ac (поддержка по желанию)

**Ширина канала** - это разница между минимальной и максимальной частотой, на которые можно передавать данные.
Чем шире канал - тем более качественно мы можем передавать данные и тем выше скорость передачи данных.

В стандарте 802.11n появилась возможность использовать 40 МГц и за счёт этого увеличивать скорость передачи.
Начиная с этого стандарта появилась возможность использовать несколько антенн для передачи и приёма сигнала.
Если у нас есть несколько антенн, то мы можем использовать несколько пространственных потоков.
**Пространственный поток** - сигнал, распространяющийся от одной антенны до другой.
Параллельная передача нескольких пространственных потоков существенно увеличивает скорость передачи данных.
При этом используется специальный метод кодирования сигналов: MIMO - **Multiple Input Multiple Output**.

**Адаптация скорости**
В Ethernet скорость передачи данных фиксирована.

Wi-Fi позволяет менять скорость при разном качестве сигнала:
* Высокое качество - скорость увеличивается
* Низкое качество - скорость уменьшается

Для того, чтобы уменьшить или увеличить скорость Wi-Fi меняет несколько параметров.
Адаптация скорости реализуется за счёт изменения:
* "Ширины" используемых каналов (20 - 160 МГц)
* Методов модуляции (Modulation type: BPSK, QPSK, 16-QAM, 64-QAM, 256-QAM)
* Интервала между сигналами (Guard Interval - интервал данных между символами, которые передаются по Wi-Fi, измеряется в наносекундах 800 ns - 400 ns)

#Wi-Fi. Управление доступом к разделяемой среде
Физический уровень Wi-Fi использует 6 стандартов IEEE 802.11
Канальный уровень Wi-Fi одинаковый для разных стандартов физического уровня.

Wi-Fi использует для передачи данных разделяемую среду - радиоэфир.
В разделяемой среде возможны коллизии.
Чтобы их избежать, необходим метод доступа к среде, который бы обеспечивал, что в один момент времени данные передает только один компьютер.

**Особенности беспроводной среды**
* Вероятность ошибки передачи данных выше, чем в проводной среде
* Мощность передаваемого сигнала намного выше, чем принимаемого
* Ограниченный диапазон распространения сигнала – не все компьютеры в сети получают данные.
Проблема скрытой станции - один компьютер расположен в зоне пересечения действия сразу двух компьютеров, которые друг друга не видят.
Проблема засвеченной станции - один компьютер в зоне действия существующей передачи видит компьютер за этой зоной действия, но не передаёт данные, так как его среда занята.

Так как ошибки при передаче данных возникают часто, то в Wi-Fi на канальном уровне используется подтверждение получения передаваемых данных.
Коллизии в Wi-Fi обнаруживаются по отсутствию подтверждений. 

**Обнаружение коллизий**
**Ethernet**
* Компьютер передаёт и одновременно принимает сигнал. При сравнении сигналов, если они отличаются - произошла коллизия.
* Jam-последовательность для усугубления коллизии

**Wi-Fi**
* Передаваемый сигнал намного мощнее принимаемого
* Проблемы скрытой и засвеченной станции
* Сигнал о коллизии может не дойти до всех компьютеров

Коллизии в Ethernet дёшевы
* Обнаруживаются сразу после возникновения
* Все компьютеры останавливают передачу данных

Коллизия в Wi-Fi обходится очень дорого
* Требуются большие временные затраты на обнаружение:
1. Время передачи кадра
2. Время тайм-аута ожидания подтверждения

Поэтому в Wi-Fi используется метод CSMA/CA - ножественный доступ с прослушиванием несущей частоты с предотвращением коллизий.

**Методы доступа к среде в Ethernet:**
* CSMA/CD - Множественный доступ с прослушиванием несущей частоты и распознаванием коллизий

**Метод доступа к среде в Wi-Fi:**
* CSMA/CA - Множественный доступ с прослушиванием несущей частоты с предотвращением коллизий (Collision Avoidance)

**Модель CSMA/CA**
Также как и в **Ethernet** перед началом передачи данных компьютеры **Wi-Fi** прослушивают несущую частоту.
Если происходит передача данных, то все остальные компьютеры ожидают завершения передачи данных.
В отличие от Ethernet в **Wi-Fi** после **передачи кадра** и **короткого межкадрового интервала** происходит **передача подтверждения (ACK)**.
После этого все компьютеры, которые хотят передавать данные должны выдержать **межкадровый интервал**.
В **Ethernet** после завершения межкадрового интервала начинается период конкуренции.
Но в **Wi-Fi**, так как коллизии обходятся очень дорого, вместо периода конкуренции используется **период молчания**.
Каждый компьютер выбирает разное время для периода молчания. Случайным образом генерируется некоторое число **слотов ожидания**.
**Слот ожидания** - это промежуток времени, в течение которого компьютер ждёт.
Длина слота ожидания разная для различных стандартов физического уровня Wi-Fi.
Количество слотов ожидания выбирается компьютерами случайным образом.
Первым начинает передавать данные тот компьютер, который выбрал меньше всего слотов ожидания.

Однако метод доступа CSMA/CA не решает проблему скрытой и засвеченной станции.

Другой метод доступа к среде в Wi-Fi:
**протокол Multiple Access with Collision Avoidance (MACA).**
Он позволяет решить проблему скрытой и засвеченной станции.
Однако на практике метода CSMA/CA почти всегда достаточно, поэтому поддержка протокола MACA в оборудовании Wi-Fi не обязательна.

**Протокол MACA**
Перед передачей данных компьютер передаёт управляющее сообщение:
* Request To Send (RTS)
* Включает размер сообщения с данными

Принимающий компьютер отвечает сообщением:
* Clear To Send (CTS)
* Также включает размер ожидаемого сообщения

Компьютеры, увидевшие CTS, ждут:
* Время на передачу данных (размер данных в CTS)
* Время на передачу подтверждения

#Wi-Fi формат кадра

Wi-Fi использует два формата кадра на канальном уровне:
* Подуровень LLC
- Здесь формат кадра такой же как и в Ethernet.
* Подуровень MAC
- Здесь формат кадра отличается.
При реальной передаче данных по беспроводной среде используется именно формат кадра уровня MAC IEEE 802.11.
Однако при поступлении на устройство, происходит автоматическое преобразование на уровень LLC либо оборудованием, либо драйвером в формат кадра Ethernet.

**Формат кадра Wi-Fi уровня MAC стандарт IEEE 802.11**
2 байта     2 байта         6 байт  6 байт  6 байт  2 байта     6 байт  0-2304 байт 4 байта
Управление  Длительность    Адрес 1 Адрес 2 Адрес 3 Управление  Адрес 4 Тело        Контрольная
кадром                                              очерёдностью        кадра       сумма

Самое заметное отличие - в кадре Wi-Fi используется 4 MAC-адреса следующего назначения:
Адрес устройства, которое принимает данные из беспроводной среды (Receiver Address)
Адрес устройства, которое передает данные в беспроводную среду (Transmitter address).
Адрес устройства получателя (Destination Address).
Адрес устройства отправителя (Source Address).

Wi-Fi чаще всего используется в инфраструктурном режиме: данные из беспроводной сети передаются в проводную сеть для последующей передачи в Интернет.
В инфраструктурном режиме для передачи данных чаще всего используются три устройства:
1. Наш компьютер
2. Точка доступа
3. Устройство в проводной среде, которое обеспечивает подключение к интернету.

В Wi-Fi адреса называются следующим образом:
DA - Destination address - адрес назначения (получателя)
SA - Source address - адрес источника (отправителя)
RA - Receiver address - устройство, принимающее данные из беспроводной среды
TA - Transmitter address - устройство, передающее данные в беспроводную среду

Начнём от **передачи кадра с нашего устройства в проводную среду и затем в Интернет**.
Проводная сеть, к которой подключается наша сеть Wi-Fi называется **распределительная система.**
Кадр передаётся от нашего компьютера к проводному маршрутизатору, который затем передаёт его в Интернет.
В этом случае в *первом поле* адреса указывается MAC-адрес точки доступа как **Receiver Address**, принимающий из беспроводной среды:
Адрес 1 Адрес 2 Адрес 3
RA      TA/SA   DA
Во втором поле *"Адрес 2"* указывается MAC-адрес компьютера. В этом случае **Transmitter Address** и **Source Address** совпадают: отправитель сам передаёт данные в беспроводную среду.
И третье поле - **Destination Address** - адрес получателя, MAC-адрес проводного устройства, которое передаёт затем наши данные в интернет.

**Когда кадр передаётся в обратном направлении** от проводного устройства через точку доступа к нашему компьютеру,
в качестве *первого адреса* указывается MAC-адрес нашего первого компьютера:
MAC-адрес нашего компьютера используется как MAC-адрес **Destination address** и
как адрес устройства, которое принимает данные из беспроводной среды: **Receiver Address**
Во *втором поле* указывается MAC-адрес точки доступа: **Transmitter Address**
и в *третьем поле* MAC-адрес отправителя: адрес маршрутизатора **(Source Address)**

Адрес 1 Адрес 2 Адрес 3
RA/DA   TA      SA

Если сеть работает в одноранговом режиме, компьютеры передают данные друг другу.
В этом случае адрес получателя **Destination address** всегда совпадает с устройством принимающим данные из беспроводной среды **Receiver address**.
А адрес отправителя **Source Address** с адресом устройства, передающего данные в беспроводную среду **Transmitter Address**.

В третьем адресе указывается идентификатор одноранговой сети BSSID, который генерируется автоматически.

#Беспроводной мост
4 адреса в заголовке Wi-Fi используются очень редко, в ситуации, которая называется беспроводной мост.
Когда есть два устройства, передающих данные друг другу через беспроводную сеть, которая объединяет две проводных сети.

Адрес 1 Адрес 2 Адрес 3 Адрес 4
RA      TA      DA      SA

Адрес проводного устройства-отправителя указывается в 4-ом поле: **Source Address**
Адрес проводного устройства-получателя в третьем поле: **Destination Address**
Точка доступа отправителя во втором поле: **Transmitter Address**
Точка доступа получателя в первом поле: **Receiver Address**

После четвёртого поля адреса, которое не является обязательным, идёт тело кадра.
Размер поля данных в Wi-Fi 2304 байта (в Ethernet размер поля данных 1500 байт).

Если при проверке поля "Контрольная сумма" произошла ошибка, такой кадр отбрасывается.

2 байта     2 байта         6 байт  6 байт  6 байт  2 байта     6 байт  0-2304 байт 4 байта
Управление  Длительность    Адрес 1 Адрес 2 Адрес 3 Управление  Адрес 4 Тело        Контрольная
кадром                                              очерёдностью        кадра       сумма

Поле "Длительность" используется вместе с управляющими кадрами, например, кадрами из протокола доступа MACA и в этом поле указывается на какое время зарезервирован канал передачи данных Wi-Fi.

**Поле "Управление кадром"**
2 бита      2 бита  4 бита  1 бит   1 бит   1 бит   1 бит   1 бит   1 бит   1 бит       1 бит
Версия      тип     Подтип  To      From    MF      RT      Power   MD      Protection  Order
протокола                   DS      DS                      Mgmt            Frame

Поле "Управление кадром" содержит большое количество управляющих флагов.
**Версия протокола** - сейчас используется 0, остальные значения зарезервированы для будущего использования.
**Тип**:
Типы кадров Wi-Fi:
1. **Кадры данных** (передача данных)
2. **Кадры контроля** (control frames). Служебные кадры
* (RTS - Request to Send - запрос на передачу, CTS - готов к передаче, ACK - подтверждение успешной передачи кадра)
3. **Кадры управления** (management frames). Реализация сервисов Wi-Fi (например, ассоциация с точкой доступа).

Затем идут два поля, указывающих направление передачи кадра.
Флаги **To Distribution System**: от проводного компьютера к распределительной системе и
**From Distribution System**: от распределительной системы к проводному компьютеру.

В Wi-Fi ошибки при передаче случаются часто:
по статистике на 2016-ый - 1 ошибка на 1000 байт.
Передавать данные при том, что размер кадра может достигать 2304 байт затруднительно.
Поэтому в Wi-Fi реализована **фрагментация**.
**Фрагментация** - это технология разделения одного кадра на несколько небольших фрагментов для отдельной передачи.
Фрагментация в Wi-Fi позволяет передавать данные, даже если ошибки возникают очень часто.
При этом кадры делятся на отдельные части (фрагменты) и передаются отдельно.
Скорость при этом падает, но данные будут передаваться.

В Wi-Fi для фрагментации используются два поля заголовка:
**Поле MF** (More Fragments)
Поле "Управление очерёдностью", которое в свою очередь состоит из двух подполей:
* Номер последовательности (Sequence Number).
Содержит номер кадра, который разбивается на отдельные небольшие фрагменты.
Для всех фрагментов одного и того же кадра номер последовательности будет одинаковым.
* Номер фрагмента (Fragment Number)

**Поле RT**  говорит о том, что происходит повторная отправка кадра.
Повторная отправка происходит в том случае, если отправитель не получил подтверждения получения кадра.
Однако может сложиться такая ситуация, что получатель отправил подтверждение получения, но оно не дошло до отправителя.
В обоих случаях отправитель устанавливает флаг **RT**.

Следующие два поля используются для управления питанием.
Wi-Fi часто используется в мобильных устройствах
* Очень важно экономить электроэнергию, чтобы продлить срок работы батареи
Технология IEEE 802.11 Power Saving Mode позволяет экономить питание при работе Wi-Fi.

Стандарт IEEE 802.11 PSM
* Режимы работы станции: активный и спящий
* В спящем режиме станция не принимает и не передаёт данные
* Точка доступа записывает кадры для "спящей" станции в буфер
* "Спящая" станция регулярно просыпается и читает все кадры от точки доступа
* Передавать кадры станция может в любое время

Флаг **Power Mgmt** используется станцией для того, чтобы сообщить точке доступа, что станция использует управление питанием и работает в спящем режиме.
Флаг **MD** More Data устанавливается точкой доступа при передаче кадра станции, которая работает в режиме сохранения питания.
При получении кадра, в котором установлен этот флаг, станция узнаёт, что у точки доступа есть ещё кадры и запрашивает их.

Флаг **Protection Frame** - Защита кадра - применяется, чтобы указать используется шифрование или нет.
Флаг **Order** - порядок - говорит о том сохраняется ли порядок сообщений или нет.
На практике кадры всегда принимаются в том же порядке, в котором отправляются.

#Сервисы Wi-Fi

В сервисах Ethernet есть только функционал **передачи данных**.
Для того, чтобы воспользоваться сетью Ethernet, нужно просто подключиться к ней проводом.

С Wi-Fi ситуация другая:
сигналы распространяются не в закрытой среде по проводам, а в открытой среде через радиоэфир.

Поэтому для обеспечения надёжной работы сети, а также защиты передаваемых данных, в Wi-Fi кроме передачи данных используются дополнительные сервисы:
* Ассоциация
Перед тем как передавать данные по беспроводной сети, к ней нужно подключиться.
* Аутентификация
Перед тем, как подключиться к сети, пользователь должен предоставить свои данные и права на пользование данной сетью.
* Передача данных
* Защита информации (шифрование)
Так как данные в беспроводной сети могут быть доступны всем, кто находится в зоне действия передатчика, для защиты данных их нужно шифровать.
* Роуминг

Wi-Fi предоставляет два Набора сервисов:
* Базовый набор сервисов (basic service set).
BSSID - идентификатор базового набора сервисов, MAC-адрес точки доступа.
* Расширенный набор серсивов (extended service set).
SSID - идентификатор набора сервисов в понятном для человека виде, текстовая строка.

BSSID наиболее распространённая.
В своём радиусе действия точка доступа рассылает идентификаторы своего набора сервисов
Basic Service Set Identifier - это просто MAC-адрес точки доступа.
(пример, BSSID: **FA:F0:82:D9:0D:10**)

Кроме этого рассылается идентификатор набора сервисов в понятном для людей виде
Service Set Identifier, тот самый, который мы видим в списке доступных сетей, когда пытаемся подключиться к Wi-Fi.

Сперва необходимо пройти **аутентификацию**. Для этого клиент, желающий подключиться к сети, отправляет ей управляющий кадр специального вида Management Frame с запросом на аутентификацию.
Если этот запрос удовлетворяет условиям точки доступа, она отвечает кадром с положительным ответом.

**Режимы аутентификации**
**Открытая аутентификация**
* Подключение без пароля
Без ограничений, шифрование не используется, все данные могут быть перехвачены.

**Personal**
Единый пароль для всех устройств в сети

**Enterprise**
Отдельные пароли для разных пользователей с применением сервера аутентификации (протоколы RADIUS, LDAP и т. п.)

После успешной аутентификации клиент высылает точке доступа запрос на **Ассоциацию**.
В этом запросе клиент передаёт параметры Wi-Fi, с которыми он может работать.
Если эти параметры подходят точке доступа, она высылает в ответ кадр с успешной ассоциацией.
Когда аутентификация и ассоциация выполнены, клиент может передавать данные через точку доступа.

Следует отметить, что если клиент хочет передавать данные другому клиенту, который также находится в этой сети, данные передаются через точку доступа.
Это реализовано для того, чтобы упорядочить общение в разделяемом эфире.

Возможна более сложная ситуация, когда после успешной ассоциации клиент подключается к сети, но не имеет права передавать данные без дополнительной внешней аутентификации.
Для того, чтобы пройти эту внешнюю аутентификацию как правило используется внешний сервер авторизации.

**Отключение клиента**
Если клиент захотел отключиться от беспроводной сети, он отправляет точке доступа запрос на **деассоциацию** или **деаутентификацию**.
Точка доступа высылает ответ и отключает клиента от сети.
Если клиент вышел из зоны сети, то его данные будут храниться до тех пор, пока он не будет отключен через установленный в сети таймаут.

**Расширенный набор сервисов**
Полезно, когда необходимо создать сеть Wi-Fi на большой территории, которая больше, чем зона действия одной точки доступа.
В этом случае используются несколько точек доступа, которые согласовано работают между собой с помощью внешнего контроллера.
Все эти точки доступа передают единый идентификатор набора сервисов Service Set Identifier в текстовом виде.
Но идентификатор базового набора сервисов - BSSID - у них разный и как правило равен MAC-адресу точки доступа.

Один из полезных сервисов расширенного набора - **роуминг**.
(Roam — бродить, странствовать)
Когда вы подключились к одной точке доступа Wi-Fi, вы можете перейти в зону действия другой точки доступа и продолжать работу.

Реализация следующая:
Вы проходите ассоциацию и аутентификацию с одной точкой доступа.
Информация о вашем устройстве сохраняется не только в точке доступа, но и в контроллере.
Когда вы перемещаетесь из зоны действия одной точки доступа в другую точку доступа, устройство присылает новой точке доступа запрос на реассоциацию.
Точка доступа извлекает информацию о клиенте из контроллера и если всё проходит хорошо, то клиент подключается к этой точке доступа и продолжает работу с сетью с тем же самым идентификатором, но через другую точку доступа.

**Сканирование**
Как клиент узнаёт какие есть точки доступа и сети там, где он находится.
**Пассивное сканирование**
Все точки доступа регулярно рассылают специальный широковещательный кадр с информацией о себе, так называемый **Beacon** frame.
Этот кадр содержит идентификатор сети (SSID: "Name string") и идентификатор набора базовых сервисов (BSSID: default - MAC).
При пассивном сканировании клиент принимает такие кадры от точек доступа и через некоторое время узнаёт о всех сетях.
**Активное сканирование**
Если клиент хочет быстрее получить информацию о доступных сетях, не дожидаясь рассылки широковещательных кадров от точек доступа, клиент может использовать активное сканирование.
Для этого рассылается специальный широковещательный запрос **Probe** к точкам доступа.
Получив такой запрос, точки доступа пересылают информацию о сетях, которые они обслуживают.

**Шифрование**
Информация, которую мы передаём по беспроводной среде доступна всем: ситуация, аналогичная работе концентратора.

**Шифрование в Wi-Fi**
* Установлен флаг Protection Frame (WEP)
Wired Equivalent Privacy - приватность эквивалентная проводному соединению
* Шифруются только данные, но не заголовки.

**Типы шифрования**
* Wired Equivalent Privacy (WEP)
уже не используется, так как его довольно просто взломать
* Wi-Fi Protected Access (WPA)
* Wi-Fi Protected Access 2 (WPA2)
в настоящее время представляет наивысшую защиту

При пользовании общественными сетями следует соблюдать осторожность, поскольку пароли могут не подлежать шифрованию.

#Network layer

Сетевой уровень (network layer) объединяет сети, построенные на основе разных технологий канального уровня:
* Ethernet
* Wi-Fi
* 5G/4G/3G
* MPLS
* ATM, TokenRing, FDDI (устаревшие)

**История создания**
Сетевой уровень - основа Интернета.
Винтон Серф и Роберт Кан
* первые выдвинули идею сетевого уровня в 1974
* их называют "Отцами Интернета"
* получили за эту идею премию Тьюринга
(эквивалентно Нобелевской премии в информационных технологиях и компьютерных науках)

Сетевой уровень необходим, потому что:
* очень много разных, отличающихся друг от друга, технологий канального уровня
* масштабируемость
технологии канального уровня хорошо подходят для локальных сетей, но плохо для глобальных

**Различия сетей**
**Сервис**
* Без гарантии доставки (Ethernet)
* С гарантией доставки (Wi-Fi)
* С гарантией доставки и порядка следования сообщений

**Адресация**
* Ethernet - MAC, Сети сотовой связи - IMEI
* Разный размер, плоская (напр. Ethernet), иерархическая

**Широковещательные**
* Поддерживается или нет

**Максимальный размер кадра (MTU)**
* Ethernet - 1500
* Wi-Fi - 2304

**Формат кадра**
В разных технологиях канального уровня разный формат кадра.

**Согласование различий в сетях**

**Тип сервиса**
Устройство, подтверждающее сети, само посылает подтверждение в Wi-Fi и не ждёт подтверждения от получателя, который работает в Ethernet, не отправляя ему подтверждений также.
* Кадры из Wi-Fi принимаются с отправкой подтверждения, а в Ethernet отправляются без подтверждений

**Адресация**
На сетевом уровне вводятся **глобальные адреса**.
Это адреса устройств в составной сети, которые не зависят от адресов в конкретных технологиях канального уровня.
В таких случаях вводятся два типа адресов: глобальный и локальный.
* Методы преобразования глобального адреса в локальный (ARP для TCP/IP)

**Широковещание**
* Пакеты отправляются всем хостам в сети по индивидуальным адресам

**Фрагментация**
При отправке кадра через сеть мы не можем заранее знать, какой максимальный размер кадра принят на выбранном маршруте.
Для того, чтобы согласовать размер кадра в технологиях канального уровня, на сетевом уровне используется фрагментация.

Устройство, объединяющее сети и принимающее данные, анализирует их размер.
Если передать их за один раз через следующую сеть нельзя, поскольку MTU меньше, чем размер данных, то:
* устройство делит данные на отдельные части - **фрагменты** и передаёт их.
Следующее устройство, объединяющее сети:
* Соединяет эти фрагменты в **пакет**.
* Анализирует размер пакета и MTU следующей сети, через которые будет передавать пакет.

Ethernet - доминирующая технология канального уровня.

Wi-Fi - в некотором смысле адаптация Ethernet для беспроводной среды:
* Формат адресов одинаков
* Формат кадра уровня LLC одинаков (Wi-Fi использует другой формат только на уровне MAC)
* Можно обеспечить согласование Wi-Fi и Ethernet без маршрутизации
(режим моста Wi-Fi маршрутизатора - режим, в котором работа Ethernet и Wi-Fi согласуется на канальном уровне)
* Распределительная система Wi-Fi проводная (сейчас на Ethernet)

Почему нельзя строить сети только на Ethernet?
Ethernet и другие технологии канального уровня не подходят для создания крупной сети, которая может охватить весь мир из-за существенных ограничений по масштабируемости.

**Масштабируемость Ethernet**
**Таблица коммутации**:
* Должна содержать MAC-адреса **всех** хостов в сети
Искать нужный хост в такой таблице будет очень долго.
* Сколько хостов в Интернет?
* Сколько памяти нужно для хранения такой таблицы?
* Как быстро будет осуществляться поиск?

**Отправка пакетов на все порты:**
* Если коммутатор не знает, где находится хост, он отправляет кадр на **все** порты
* Сколько "лишних" кадров будет передаваться в Интернет?

**Отсутствие дублирующих путей между коммутаторами**:
* STP обнаруживает и отключает дублирующие пути
* Активный путь всегда только один

**Масштабируемость на сетевом уровне**
Сетевой уровень работает с блоками адресов.
**Агрегация адресов**:
* Работа не с отдельными адресами, а с блоками адресов
* Блок адресов - сеть

**Запрет пересылки "мусорных" пакетов:**
* Пакет отбрасывается, если нельзя определить, куда его нужно отправлять

**Возможность наличия нескольких активных путей в сети**:
* Одна из основных причин создания сетей с пакетной коммутацией
* Допускается несколько активных путей
* Задача выбора лучшего пути - маршрутизация

**Задачи сетевого уровня:**
* Объединение сетей, построенных на основе разных технологий канального уровня (**internetworking**).
* Маршрутизация - поиск маршрута пакета в крупной составной сети.
* Обеспечение качества обслуживания

Устройство сетевого уровня - маршрутизатор.
**Маршрутизатор** - это устройство для объединения сетей.
У маршрутизатора есть несколько **интерфейсов**. Через эти интерфейсы к маршрутизатору подключаются сети.
У каждого интерфейса на маршрутизаторе есть свой адрес.
(Для сравнения: у интерфейсов коммутаторов своих адресов нет).
Если мы хотим объединить несколько сетей, маршрутизатор необходим.
Нельзя просто подключить две сети напрямую и передавать между ними данные.

**Маршрутизация**
**Маршрутизация** (routing) - это поиск маршрута доставки пакетов данных между сетями через транзитные узлы - маршрутизаторы.
При этом необходимо вести:
* Учёт изменений в топологии сети
* Учёт загрузки каналов связи и маршрутизаторов

**Продвижение** (forwarding) - передача пакета внутри маршрутизатора в соответствии с правилами маршрутизации.

Протоколы сетевого уровня стека TCP/IP:
- IP (Internet Protocol) основной протокол для передачи данных
- ICMP (Internet Control Message Protocol) - используется для управления сетью
- ARP (Address Resolution Protocol) - для определения по глобальному адресу сетевого уровня (ip) определить локальный адрес в технологии канального уровня
- DHCP (Dynamic Host Configuration Protocol) - протокол динамической конфигурации хостов, используется для того, чтобы автоматически назначать ip адреса компьютерам в составной сети.

#IP Addresses

В сетях используются два типа адресов: локальные и глобальные.
**Локальные адреса**:
* Адреса в технологии канального уровня
* Пример: MAC-адрес в Ethernet, IMEI в 4G
* Привязаны к одной технологии
* Не могут быть использованы в гетерогенных сетях
Не могут использоваться для построения крупной составной сети, которая включает в себя сети, использующие разные технологии.

**Глобальные адреса**:
* Адреса сетевого уровня
* Пример: IP адреса
* Не привязаны к технологии
* Применяются при объединении сетей

**IP адреса**
Глобальные адреса, используемые в стеке протоколов TCP/IP.
Используются для уникальной идентификации компьютеров в составной сети. Широко используются в Интернет.

Существует две версии протокола IP:
- IPv4: адрес 4 байта
- IPv6: адрес 16 байт

**Длина адреса IPv4** – 4 байта, 32 бита.
Форма представления: 4 десятичных числа 0-255, разделенных точками.
Для удобства, адрес делят на 4 части по 8 бит. Такую часть называют октет.
Каждый октет записывают в десятичном формате, например:
11010101 10110100 11000001 00000011
    213     180     193     3
213.180.193.3

**IP-адреса и IP-сети**
Сетевой уровень использует агрегацию адресов:
* Масштабирование - работа не с отдельными адресами, а с подсетями.
Подсеть (IP-сеть, сеть, subnet) – множество компьютеров, у которых старшая часть IP-адреса (первые 3 октета) одинаковая.
Примеры:
213.180.193.1
213.180.193.2
213.180.193.3
...
213.180.193.254

Маршрутизаторы работают с подсетями, а не отдельными компьютерами.

**Структура IP-адреса:**
* Номер подсети – старшие биты
* Номер хоста (компьютера в сети) – младшие биты
Пример структуры:
* IP-адрес: 213.180.193.3
* Номер подсети: 213.180.193.0
* Номер хоста: 3 (0.0.0.3)

Маска подсети показывает, где в IP-адресе номер сети, а где хоста.
**Структура маски:**
* Длина 32 бита.
* Единицы в позициях, задающих номер сети.
* Нули в позициях, задающих номер хоста.

Применение логического **AND** маски подсети к IP-адресу даёт адрес подсети.

**Представление маски подсети**.
**Десятичное представление:**
* IP-адрес: 213.180.193.3
* Маска подсети: 255.255.255.0
* Адрес подсети: 213.180.193.0

**Представление в виде префикса:**
Указано сколько первых бит адреса относятся к адресу подсети.
* 213.180.193.3 / 24
* Адрес подсети: 213.180.193.0

Оба представления эквивалентны.

**Маска подсети переменной длины**
Важно понимать, что маска подсети не обязательно должна заканчиваться на границе октетов.

213.180.193.3 /20
IP:         11010101.10110100.11000001.00000011
                         AND
MASK:       11111111.11111111.11110000.00000000
Subnet:     11010101.10110100.11000000.00000000
Subnet
(decimal):  213.180.192.0
Host
(decimal):  0.0.1.3
Адрес хоста включает в себя все незанятые подсетью биты.

**Устаревший метод классов IP-адресов**
Диапазоны жёстко заданы, класс определяется по первым битам.

Класс A (в бинарном виде начинаются на 0)
1.0.0.0 - 126.0.0.0
К адресу сети относится первый октет.
Класс B (в бинарном виде начинается на 10)
128.0.0.0 - 191.255.0.0
К адресу сети относятся первые 16 бит.
Класс C (110)
192.0.0.0 - 223.255.255.0
Наиболее распространённый класс для сетей, включающих в себя до 254 компьютеров.
Класс D - групповые адреса
224.0.0.0 - 239.255.255.255
Класс E - зарезервирован для будущего использования
240.0.0.0 - 255.255.255.255

**Типы IP-адресов:**
* Индивидуальный (unicast)
Адрес конкретного компьютера в сети.
* Групповой (multicast)
Адрес, использующийся несколькими компьютерами.
При отправлении сообщения на этот адрес, его получат несколько компьютеров, входящих в данную группу.
* Широковещательный (broadcast)
Адрес для получения данных всеми компьютерами в сети.

**Широковещательный адрес**
Рассматриваются правила образования широковещательного адреса и два типа широковещания в IP:
* **Направленное широковещание**.
Когда компьютер за пределами нашей сети хочет передать широковещательный пакет всем устройствам в нашей сети.
Широковещательный адрес: ХХХ.ХХХ.Х.255, где Х - адрес подсети.
Пакет передаётся маршрутизатору, маршрутизатор разошлёт этот пакет в широковещательном режиме, но в пределах одной указанной подсети.
* **Ограниченное широковещание**.
Когда мы направляем широковещательный пакет в рамках одной сети.
Широковещательный адрес: 255.255.255.255
Данные получают все компьютеры в сети, а через маршрутизатор данные не пройдут.

**Формат широковещательного адреса**:
* В номере хоста все единицы
* IP-адрес: 213.120.193.3 / 24
* Широковещательный адрес: 213.180.193.255

В IP широковещательные пакеты передаются только внутри подсети (ограниченное широковещание)
* Маршрутизаторы не пересылают широковещательные пакеты
* Нет возможности указать в адресе "все компьютеры в Интернет" (пакет "Godzillagram")

**Специальные IP-адреса**
В номере хоста нельзя использовать только битовые 0 или 1.

Битовые 0 в номере хоста - это адрес подсети.
* Адрес подсети: 213.180.193.0

Битовые 1 в номере хоста - это широковещательный адрес.
* Широковещательный адрес: 213.180.193.255

Договорённость (не обязательная):
часто хост с номером один - это маршрутизатор или шлюз, через который все компьютеры в сети попадают в интернет.
* Хост с номером 1 - маршрутизатор по умолчанию (шлюз):
213.180.193.1

0.0.0.0 - адрес текущего хоста (подсеть), используется когда компьютер ещё не получил свой IP-адрес.
255.255.255.255 - все хосты в текущей подсети (ограниченный широковещательный адрес)

127.0.0.0/8 - обратная петля (loopback)
Специальный диапазон адресов, выделенный для отладки сетевых приложений.
* Сеть для тестирования
* Данные не передаются в сеть, а приходят обратно
* 127.0.0.1 - localhost (текущий компьютер)

169.254.0.0/16 - Link-local адреса
* Назначаются ОС хоста автоматически, если недоступна другая конфигурация IP
(Если не настроен IP-адрес на компьютере вручную или иным способом (например, протокол DHCP))/
* Могут использоваться в пределах подсети
* Не проходят через маршрутизатор

**Распределение IP-адресов**
Все IP-адреса в интернет должны быть уникальными.
Поэтому нельзя использовать любые адреса, нужно получать разрешение у **Internet Assigned Numbers Authority (IANA)**.
Сейчас эту роль выполняет корпорация **ICANN (Internet Corporation for Assigned Names and Numbers).** https://www.icann.org
Однако делает она это не напрямую, а с помощью национальных регистраторов.
Региональные регистраторы (RIR - Regional Internet Register)
В каждом регионе есть свой регистратор, взаимодействующий с корпорацией ICANN.

**Частные IP-адреса**
Однако часто бывают случаи, когда вы создаёте сеть, которая использует IP-адреса, но при этом она не подключена к интернету.
Например, внутренняя сеть организации или внутренняя сеть класса, в которой вы просто тестируете какие-то технологии.
Для этого случая выделены зарезервированные диапазоны адресов (RFC 1918), которые можно использовать без обращения в ICANN:
* 10.0.0.0 /8
* 172.16.0.0 /12
* 192.168.0.0 /16
Эти адреса не маршрутизируются в интернет.
Могут использоваться внутри организации без обращения в IANA
Однако есть возможность подключить сеть, построенную на основе частных адресов, к Интернет.
Для этого используется технология **NAT (Network Address Translation).**

**Исчерпание IP-адресов**
Длина IPv4 адреса 32 бита.
* Максимум 4 294 967 296 (2 в 32 степени) IP-адресов.
Этого было достаточно во времена разработки протокола IP, но не сейчас. В настоящее время почти все адреса IPv4 распределены и получить новый не реально.

**Пути решения**:
* Переход на IPv6 (длина адреса 16 байт)
* Использование технологии NAT
В основном используются частные сети, но выход в интернет происходит через один хост, использующий динамическую трансляцию адресов.

# Internet Protocol

**IP (Internet Protocol) - межсетевой протокол**
* internetworking - объединение сетей
* internet - объединённая сеть / subnet - подсеть
* Internet - название самой крупной объединённой сети, построенной по протоколу IP.
**Основа сети Интернет**
И в модели OSI и в модели TCP/IP она находится на сетевом (network) уровне.

**Сервисы IP**
**Передача данных**
* Без гарантии доставки
* Без сохранения порядка следования сообщений

Протокол IP использует передачу данных без установки соединения
(IP-пакет просто отправляется в сеть в надежде, что он дойдёт до получателя)
Если пакет на дошёл, не предпринимается никаких попыток предупредить отправителя или отправить этот пакет снова.
Считается, что ошибка должна быть исправлена протоколами на вышестоящих уровнях.

**Задачи IP**
* Объединение сетей
* Маршрутизация
* Качество обслуживания

**Формат заголовка IP-пакета**
|------------------------------------------------------------
|4 бита |4 бита    | 8 бит       |          16 бит          |
|Номер  |Длина     | Тип         |      Общая длина         |
|версии |заголовка | сервиса     |                          |
|------------------------------------------------------------
|       16 бит                   |3 бита |      13 бит      |
|Идентификатор пакета            |Флаги  |Смещение фрагмента|
|------------------------------------------------------------
|   8 бит          |    8 бит    |      16 бит              |
|   Время жизни    |Тип протокола|  Контрольная сумма       |
|------------------------------------------------------------
|                       32 бита                             |
|                 IP-адрес отправителя                      |
|------------------------------------------------------------
|                       32 бита                             |
|                 IP-адрес получателя                       |
|------------------------------------------------------------
|                 Опции и выравнивание                      |
|                   (не обязательно)                        |
|------------------------------------------------------------

**Версия IP**
Сейчас существует две версии IP: 4 и 6.
IPv4
* Длина IP-адреса 4 байта
* Нехватка IP-адресов
* Используется сейчас
IPv6
* Длина IP-адреса 16 байт
* Вводится в эксплуатацию

**Длина заголовка**
В отличие от Ethernet, заголовок IP-пакета может включать в себя не только обязательные поля, но и дополнительные (опции).
Сюда записывается общая длина как обязательной части, так и опции.

**Тип сервиса** поле используется для обеспечения необходимого качества обслуживания, но сейчас не используется.

**Общая длина**
Общая длина - длина пакета, включая заголовок и данные.
Измеряется в байтах.
Максимальное значение - 65535 байт.
На практике длина выбирается с учётом размера кадра канального уровня
* 1500 байт для Ethernet.

Поля **Идентификатор пакета**, **Флаги** и **Смещение фрагмента** используются для реализации фрагментации.
**Время жизни** - (TTL, Time To Live) - максимальное время, в течение которого пакет может перемещаться по сети.
Введено для предотвращения "бесконечного" продвижения пакетов.

**Единицы измерения:**
* Секунды
(Но сейчас маршрутизаторы передают пакеты много быстрее, чем за секунды)
* Прохождение через маршрутизатор (hop)

**Тип протокола**
Поле предназначено для реализации функции мультиплексирования/демультиплексирования.
То есть передачи с помощью протокола IP данных от разных протоколов следующего уровня.
Код протокола, данные которого передаются:
* TCP - 6
* UDP - 17
* ICMP - 1

**Контрольная сумма** используется для проверки правильности доставки пакета.
Если при проверке контрольной суммы обнаруживается ошибка, то пакет отбрасывается.
Пересчитывается на каждом маршрутизаторе, из-за того, что заголовки меняются (как минимум "Время жизни")

**Опции**
Заголовок IP-пакета может включать дополнительные поля:
* Записать маршрут
(опция для диагностики сети. В IP-пакет записывается адрес каждого маршрутизатора, через который он проходит).
* Маршрут отправителя
(опции позволяют отказаться от автоматической маршрутизации и задать маршрут отправителя).
1. Жесткая маршрутизация
(явно указан перечень маршрутизаторов).
2. Свободная маршрутизация
(указываются только некоторые маршрутизаторы, через которые должен пройти пакет).
* Временные метки
(опция для диагностики сети. Каждый маршрутизатор записывает время прохождения пакета).

**Заполнение**:
* Опции могут иметь разный размер
* Длина заголовка IP-пакета должна быть кратна 32 битам
Поэтому, при необходимости, для выравнивания до 32 бит поле опций дополняется нулями

#Маршрутизация
**Маршрутизация** – поиск маршрута доставки пакета между сетями через транзитные узлы – маршрутизаторы.

Этапы маршрутизации:
* Изучение сети
* Продвижение (**forwarding**) пакетов на маршрутизаторе
когда сеть уже изучена.
Маршрутизатор определяет в какой из интерфейсов, к которым подключены сети, отправлять пакет.
Дальше маршрутизатор определяет нужно ли передавать пакет в саму сеть или на один из маршрутизаторов, подключённых к этой сети.
Если второй вариант - маршрутизатору необходимо выбрать на какой из маршрутизаторов передать пакет.

Эту информацию маршрутизатор получает из таблицы маршрутизации.
**Таблица маршрутизации**
В упрощённом виде она содержит:
* Адрес сети
* Маска подсети
* Шлюз
Что делать с пакетом, который вышел через заданный интерфейс.
Если состояние "On link", то сеть подключена к маршрутизатору, и пакет нужно передавать в сеть напрямую.
Если пакет нужно передать на следующий маршрутизатор, то в поле "шлюз" указывается адрес этого маршрутизатора.
* Интерфейс
Через какой интерфейс маршрутизатора нужно отправить пакет.
* Метрика.
Сейчас метрика учитывает не только количество маршрутизаторов, но и скорость каналов между сетями и загрузку каналов.

В линукс таблица маршрутизации выглядит иначе.
Основное отличие - идентификаторы интерфейсов.
Вместо IP-адресов используются названия интерфейсов.
Например:
wlan0 - название для беспроводного сетевого интерфейса,
eth0 - название для проводного сетевого интерфейса.

**Записи в таблице маршрутизации**
**Статические**
* Настраиваются вручную
Удобно, если сеть небольшая.
* Конфигурация интерфейсов
* Вручную прописанные маршруты к сетям

**Динамические**
* Настраиваются автоматически
* Протоколы маршрутизации RIP, OSPF, BGP и др.
Сами изучают сеть.
**Преимущества:** изменения в сети обновляются автоматически и учитывают выход из строя одного из маршрутизаторов или появление нового маршрутизатора.

**Маршрут по умолчанию**
Маршрутизатор должен знать обо всех существующих сетях, что на практике невозможно.

Маршрутизатор по умолчанию (шлюз, default router, gateway) - маршрутизатор, на который отправляются пакеты, для которых неизвестен маршрут доставки.
Как правило это маршрутизатор, который подключен к интернет.
Предполагается, что он лучше знает структуру сети.
Условное обозначение:
* 0.0.0.0, маска 0.0.0.0
* default

Destination     Gateway         Genmask         Metric Use Iface
0.0.0.0         10.0.59.9       0.0.0.0         600    0   wlp2s0

**Длина маски подсети**
Рассмотрим ситуацию, при которой маршрутизатор принял пакет с адресом получателя:
* 192.168.100.23

В таблице маршрутизации две записи:
* 192.168.100.0/24
* 192.168.0.0/16

Выбирается та запись, где маска длиннее.
Предполагается, что запись с более длинной маской содержит лучший маршрут интересующей нас сети.
**Правила маршрутизации:**
* Самая длинная маска: 32 - это путь к хосту.
Если в таблице маршрутизации есть такой путь, то выбирается он.
* Поиск маршрута к сети (с маской максимальной длины).
* Маршрут по умолчанию (маска /0, подходят все IP-адреса).

Таблица маршрутизации есть не только у маршрутизаторов, но и у всех хостов в сети.

# Fragmentation

**Фрагментация** - разделение пакета на несколько частей (фрагментов) для передачи по сети с маленьким MTU.
Флаги.
Размер поля флаги - 3 бита.
Значения полей:
* Первый бит зарезервирован и не используется
* DF (Don't Fragment) - не фрагментировать
* MF (More Fragments) - есть ещё фрагменты

**Смещение фрагмента**
Смещение фрагмента в поле данных исходного пакета измеряется в 8-байтовых блоках.

**Пример**
* Исходный пакет 4000 байт (заголовок 20 байт, данные 3980 байт)
* MTU целевой сети 1500 байт (заголовок 20 байт, данные 1480 байт)
* Три фрагмента: данные 0-1479, 1480-2959, 2960-3980.
* Смещение фрагментов: 0, 185, 370
Берём значение первого байта и делим на 8 (0 / 8, 1480 / 8, 2960 / 8).

**Сборка пакета**
При сборке фрагмента принимающий маршрутизатор обращает внимание либо на поле "Смещение фрагмента", либо на поле MF.
Если то или другое отлично от нуля, значит есть ещё фрагменты и маршрутизатор:
запоминает номер пакета,
высчитывает размер исходного пакета,
собирает данные в один пакет.

**Запрет на фрагментацию**
Флаг DF запрещает фрагментацию пакета.

Если MTU сети меньше размера пакета
* Маршрутизатор отбрасывает пакет
* Получателю отправляется ICMP сообщение Тип 3, Код 4 (Destination Unreachable, Fragmentation required, and DF flag set).

#Управляющие протоколы сетевого уровня

Протокол IP используется для передачи данных на сетевом уровне. Но для корректной работы крупной составной сети одного протокола IP недостаточно.
Для обеспечения работы крупной сети используются управляющий протоколы сетевого уровня:
* DHCP - для автоматического назначения IP адресов.
(Dynamic Host Configuration Protocol) - протокол динамической конфигурации хостов
Для работы в сети компьютеру нужен IP-адрес.
Методы назначения IP-адресов:
1. Вручную
2. Автоматически
Протокол DHCP позволяет автоматически назначать компьютерам в сети IP-адреса.
* ARP - для связи сетевого уровня с канальным (автоматического определения MAC-адреса компьютера по его IP-адресу).
(Address Resolution Protocol) - протокол разрешения адресов
**Адреса компьютера в сети:**
* Сетевой уровень: IP-адрес (192.168.10.43)
* Канальный уровень: MAC-адрес (54:BE:F7:88:15:47)
Протокол ARP позволяет определить по IP-адресу компьютера его MAC-адрес.
* ICMP - для передачи сообщений об ошибках и диагностики работы сети
(Internet Control Message Protocol) - протокол межсетевых управляющих сообщений
**Сообщения об ошибках в сети:**
* Получатель недоступен
* Закончилось время жизни пакета (TTL)
* Запрещено фрагментировать пакет
**Тестирование работы сети:**
* ping (проверка доступности получателя)
* traceroute (определение маршрута к получателю).

# DHCP
Протокол DHCP позволяет назначать IP-адреса компьютерам в сети автоматически.
Требует создания инфраструктуры (DHCP сервер внутри сети) и поддержания её.
IP-адреса компьютеров могут меняться.

Протокол DHCP работает по модели **клиент-сервер**:
**Клиент DHCP** - это компьютер, который получает IP-адрес автоматически.
**Сервер DHCP**:
Компьютер, который обеспечивает назначение IP-адресов и ведёт таблицу выделенных IP-адресов, чтобы избежать дублирования.
Клиент и сервер обмениваются **сообщениями DHCP** в режиме запрос-ответ.

Когда клиент включается, у него нет никакой информации о том, в какой сети он находится.
Его первая задача - узнать, где находится DHCP сервер.

Сообщения DHCP:
* DISCOVER - Поиск DHCP сервера
отправляется на широковещательный адрес.
* OFFER - Предложение IP-адреса DHCP сервером клиенту
когда сервер получает от клиента DHCP-DISCOVER он направляет в ответ OFFER, в который включает IP-адрес, который предлагает использовать клиенту.
* REQUEST - Запрос IP-адреса DHCP клиентом
Клиент в ответ посылает DHCP-REQUEST с тем же самым адресом.
* ACK - Подтверждение назначения IP-адреса DHCP клиенту
* NACK - Запрет использования запрошенного DHCP клиентом IP-адреса
Если клиент получил искажённый IP-адрес и отправил REQUEST на него, то в ответ он получит NACK.
После получения этого ответа клиент ждёт какое-то время и инициирует запрос DISCOVER заново.
* RELEASE - Освобождение IP-адреса
(который уже не нужен клиенту)
* INFORM - Запрос и передача дополнительной конфигурационной информации
(выполняется если клиент уже знает свой IP-адрес и ему не нужно получать его с помощью протокола DHCP)

Для получения IP-адреса используются следующие сообщения: DISCOVER, OFFER, REQUEST, ACK (сокращенно DORA).

**Назначение адресов в DHCP**

Два способа назначения адресов:
**Фиксированный**
* Выделенный IP-адрес для каждого MAC-адреса.
**Динамический**
* Выделение компьютеру любого IP-адреса из пула адресов

**Пул адресов**
* Список (диапазон) IP-адресов, которые назначает DHCP сервер.
* DHCP сервер следит за уникальностью распределения адресов.

**Время аренды в DHCP**
DHCP-сервер выдает IP-адрес DHCP-клиенту на ограниченное время, которое называется время аренды (lease time).
Типичное время: 1 час, 1 сутки, 3 суток и т. д.

После его окончания IP-адрес освобождается, но DHCP-клиент может продлить использование IP-адреса при необходимости:
* Продление после половины срока аренды
* Сокращённая процедура получения IP-адреса.
Так как клиент уже знает свой IP-адрес, он сразу посылает DHCP-REQUEST с IP-адресом.

**Прекращение использования адреса**
**Окончание использования IP-адреса**
* Сообщение DHCP-RELEASE
* Сервер может назначить освободившийся адрес другому клиенту
Сообщение DHCP-RELEASE автоматически отправляется современными ОС при корректном выключении

**Отсутствие сообщения DHCP RELEASE**
* До окончания срока аренды DHCP-сервер считает IP-адрес занятым
* После окончания аренды адрес освобождается

**Конфигурационная информация**
Для работы в сети нужен не только IP-адрес.
По DHCP также назначаются дополнительные параметры конфигурации сети.
Для передачи этих параметров служат DHCP-опции.
Как правило нужно знать:
* Маску подсети
* Маршрутизатор по умолчанию (шлюз)
Примеры часто используемых опций:
* Адреса DNS-серверов
* Адреса серверов времени
* Маршруты
* Имя домена

**Поиск DHCP сервера в сети**
Важно располагать DHCP-сервер в той же сети, где находятся DHCP-клиенты, которые будут получать адреса по протоколу DHCP.

Чтобы решить проблему поиска DHCP-сервера, располагающегося **через** маршрутизатор, используется конфигурация маршрутизатора **DHCP-Relay.**
Она позволяет передавать через себя широковещательный трафик, который относится к протоколу DHCP.

# ARP
Address Resolution Protocol (ARP) – протокол разрешения адресов.

Сетевое взаимодействие выполняется с использованием IP-адресов:
* ping 192.168.10.43 - либо напрямую
* ssh server.university.org - либо с помощью системы доменных имён, которые уже преобразуются в ip-адреса.

Но в реальности данные передаются с помощью технологии канального уровня:
* Ethernet, Wi-Fi, MAC-адреса
которые не знают ничего об IP-адресах.

Необходимы средства определения MAC-адреса компьютера по его IP-адресу.

Самое простое средство: **таблица соответствия**

arp
Address                  HWtype  HWaddress           Flags Mask            Iface
10.0.59.76               ether   94:57:a5:cf:1b:ac   C                     wlp2s0
10.0.59.15               ether   5c:93:a2:fe:63:c6   C                     wlp2s0
10.0.59.55               ether   d4:6d:6d:f6:c5:3e   C                     wlp2s0
10.0.59.114                      (incomplete)                              wlp2s0
10.0.59.230              ether   40:a8:f0:ad:5d:f3   C                     wlp2s0
10.0.59.135              ether   08:d2:3e:01:d8:0d   C                     wlp2s0
10.0.59.46               ether   e0:94:67:31:46:47   C                     wlp2s0
10.0.59.43               ether   d0:37:45:c5:fe:dc   C                     wlp2s0
 gateway                 ether   04:2a:e2:eb:3f:c5   C                     wlp2s0
10.0.59.115              ether   e4:a8:df:97:42:26   C                     wlp2s0

**Протокол ARP** позволяет автоматически определить MAC-адрес компьютера по его IP-адресу.
ARP работает в режиме запрос-ответ.

**Формат ARP-запроса**

**Поле**            **Значение**
Тип сети            1 (какое оборудование используем. 1 - Ethernet)
Тип протокола       2048 (IP)
Длина локального    6 (байт)
адреса
Длина глобального   4 (байт)
адреса
Операция            1 (код операции 1 - ARP-запрос)
Локальный адрес     1C:75:08:D2:49:45
отправителя         (данные отправителя, чтобы получатель знал, кому отправлять ответ)
Глобальный адрес    192.168.10.15
отправителя
Локальный адрес
получателя          00:00:00:00:00:00
Глобальный адрес    (локальный адрес получателя неизвестен и заполняется нулями)
получателя          192.168.10.43

Формат ARP-ответа точно такой же, только в поле **"Операция"** стоит цифра 2 и заполнен **локальный адрес отправителя** (MAC-адрес отозвавшегося компьютера).
В модели OSI ARP-протокол находится между канальным и сетевым уровнем.
Пакеты ARP вкладываются напрямую в кадры Ethernet без IP.

Из-за того, что ARP находится ниже сетевого уровня, ARP-пакеты не проходят через маршрутизаторы.
Таким образом с помощью ARP-протокола можно узнать только MAC-адрес компьютеров, которые находятся в одной сети.
Это происходит потому, что ARP-запрос поступает на широковещательный адрес.

**ARP-таблица**
Компьютеры в сети записывают информацию о найденных MAC-адресах в кэш.
* Нет необходимости запрашивать MAC-адрес при каждом отправлении

ARP-таблица хранит данные о соответствии MAC и IP-адресов.
* arp -a

(10.0.59.76) at 94:57:a5:cf:1b:ac [ether] on wlp2s0
(10.0.59.15) at 5c:93:a2:fe:63:c6 [ether] on wlp2s0
(10.0.59.55) at d4:6d:6d:f6:c5:3e [ether] on wlp2s0
(10.0.59.114) at <incomplete> on wlp2s0
(10.0.59.230) at 40:a8:f0:ad:5d:f3 [ether] on wlp2s0
(10.0.59.135) at 08:d2:3e:01:d8:0d [ether] on wlp2s0
(10.0.59.46) at e0:94:67:31:46:47 [ether] on wlp2s0
(10.0.59.43) at d0:37:45:c5:fe:dc [ether] on wlp2s0
gateway (10.0.59.9) at 04:2a:e2:eb:3f:c5 [ether] on wlp2s0
(10.0.59.115) at e4:a8:df:97:42:26 [ether] on wlp2s0

Записи бывают двух видов: **статическая** (внесённая вручную) и **динамическая** (добавленная в результате ARP-запроса).
Динамические записи имеют срок жизни, после которых они удаляются.

**Оптимизации ARP**
**Извлечение информации из ARP-запроса**
* Запросы отправляются на широковещательный адрес
Благодаря тому, что компьютер указывает в нём свои MAC и IP адреса, все остальные компьютеры имеют возможность записать эти данные в собственную ARP-таблицу:
* Все компьютеры извлекают и запоминают IP и MAC-адреса отправителя запроса

**Добровольный ARP-запрос (Gratuitous ARP):**
* Запрос собственного IP-адреса
* Используется при назначении нового IP-адреса для быстрого оповещения всех компьютеров в сети
* Предотвращение использования одинаковых IP-адресов в сети
Если на добровольный ARP-запрос пришёл ответ, значит какой-то другой компьютер в сети уже использует этот IP-адрес.

RFC 826 - An Ethernet Address Resolution Protocol
https://tools.ietf.org/html/rfc826

# Protocol ICMP
ICMP (Internet Control Message Protocol) - протокол межсетевых управляющих сообщений.

Протокол IP предоставляет сервис передачи данных без гарантии доставки:
* В случае ошибки при передаче пакета никаких действий не предпринимается

**Функции ICMP**
* Оповещение об ошибках на сетевом уровне
* Тестирование работоспособности сети

Сообщения об ошибках ICMP необязательно должны обрабатываться.

**Формат заголовка ICMP**
1 байт      1 байт      2 байта
Тип         Код         Контрольная
сообщения   сообщения   сумма
            4 байта
    Зависит от типа и кода сообщения
            Поле данных
**Тип сообщения** говорит о том, что произошло в сети:
какая ошибка или какое действие по диагностике пытаются выполнить.
**Код сообщения** более подробно описывается тип ошибки или её причина, или диагностическое действие.
**Контрольная сумма** используется для проверки правильности информации.
Следующие 4 байта - служебная информация.
**Поле данных** как правило включается фрагмент пакета, при передаче которого произошла ошибка.

**Типы ICMP-сообщений**
ICMP-сообщения делятся на:
**запрос-ответ** (например, 0 и 8, 13 и 14)
Эти запросы используются для проверки быстродействия сети.
И просто сообщения без запросов
Например, тип 3 - сообщение об ошибке "Узел недостижим".
0	 	Эхо-ответ (ping-отклик)
3	 	Адресат недостижим
5	 	Переадресовать (изменить маршрут)
8	0	Эхо запроса (ping-запрос).
9	0	Объявление маршрутизатора
Маршрутизаторы в сети периодически рассылают такие сообщения, чтобы компьютеры, которые находятся в сети, могли узнать какие есть маршрутизаторы.
10	0	Запрос маршрутизатора
Если компьютер только подключился к сети, он может не дожидаться сообщения от маршрутизатора, а отправить такой запрос и получит ответ от маршрутизатора.
11	 	Для дейтограммы/пакета время жизни истекло (ttl=0):
12	 	* Проблема с параметрами дейтограммы
13	 	Запрос временной метки
14	 	Временная метка-отклик
15	 	Запрос информации (устарел)
16	 	Информационный отклик (устарел)
17	 	Запрос адресной маски
18	 	Отклик на запрос адресной маски

Следующее поле - **код сообщения**
Примеры для типа 3: Узел недостижим
0	* Сеть недостижима
1	* ЭВМ (узел) не достижима
2	* Протокол не доступен
3	* Порт не доступен
4 	* Необходима фрагментация сообщения
5	* Исходный маршрут вышел из строя
6	* Сеть места назначения не известна
7	* ЭВМ места назначения не известна
8	* Исходная ЭВМ изолирована
9	* Связь с сетью места назначения административно запрещена
10	* Связь с ЭВМ места назначения административно запрещена
11	* Сеть не доступна для данного вида сервиса
12	* ЭВМ не доступна для данного вида сервиса
13	* Связь административно запрещена с помощью фильтра.
14	* Нарушение старшинства ЭВМ
15	* Дискриминация по старшинству

**Применение ICMP**
Для диагностики сети используются ping и traceroute.
**Утилита ping** необходима для доступности компьютера в сети.
Эхо-протокол ICMP:
Компьютер-источник отправляет Эхо-запрос ICMP (Тип = 8, Код = 0)
Принимающий компьютер, отвечает Эхо-ответ ICMP (Тип = 0, Код = 0)

**Утилита traceroute**
traceroute определяет маршрут от отправителя к получателю.
Находит адреса всех маршрутизаторов, через которые проходит пакет.
Чтобы установить этот перечень, утилита использует инкремент в TTL, начиная с TTL=1.
Поочерёдно каждый маршрутизатор на пути отбрасывает истёкший пакет и отправляет ICMP-сообщение с типом 11, кодом 0.
Утилита traceroute из заголовка этого IP-пакета извлекает IP-адрес маршрутизатора.

Информация:
http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml

# Передача пакетов на сетевом и канальном уровнях

Канальный уровень используется для передачи данных в одном сегменте сети,
сетевой - для объединения сетей в одну крупную составную сеть.

Адреса:
* Канальный уровень: MAC
* Сетевой уровень: IP
В каждом пакете содержится 2 адреса: IP (сетевого уровня) и MAC (канального уровня).

Рассматриваются различные варианты передачи пакетов: в рамках одной сети и через маршрутизатор.
В пределах одного сегмента при для передачи пакета, компьютер сперва формирует пакет:

**Адрес отправителя   Адрес получателя**
**192.168.1.1         192.168.1.5**
**7c-e9-d3-5f-8f-8f**
Полные адреса отправителя нам известны.
Но в адресе получателя нам известен лишь IP-адрес.
Тогда отправитель формирует ARP-запрос по широковещательному каналу данной сети,
получает в ответ ARP-ответ, и вставляет полученный MAC-адрес в пакет для отправки:
**Адрес отправителя   Адрес получателя**
**192.168.1.1         192.168.1.5**
**7c-e9-d3-5f-8f-8f   4c-72-b9-e0-1f-62**

Вариант с разными сетями.
Начало такое же:
**Адрес отправителя   Адрес получателя**
**192.168.1.1         10.0.2.11**
**7c-e9-d3-5f-8f-8f**
1. Проверяем находится ли получатель в одной сети с нами.
Для этого мы берём адрес нашей сети (допустим 192.168.1.0/24)
и проверяем подходит ли адрес получателя под эту сеть.
Если нет, то пакет необходимо передать маршрутизатору (адрес берётся из таблицы маршрутизации).
Определяем MAC-адрес маршрутизатора (ARP-протокол или ARP-таблица).
Записываем MAC-адрес маршрутизатора в MAC-адрес получателя:
**Адрес отправителя   Адрес получателя**
**192.168.1.1         10.0.2.11**
**7c-e9-d3-5f-8f-8f   00-07-e9-5b-fb**
2. Передаём пакет на маршрутизатор.
Маршрутизатор принимает пакет и готовит его для передачи по следующей сети.
IP-адреса отправителя и получателя остаются без изменений, а MAC-адреса меняются.
В MAC-адрес отправителя вставляется MAC-адрес маршрутизатора в новой сети.
А в MAC-адрес получателя записывается MAC-адрес компьютера-получателя.

Пример: маршрутизатор имеет два интерфейса:
**исходная сеть:** (интерфейс 1)
10.0.2.11
00-07-e9-5b-fb
**Искомая сеть:** (интерфейс 2)
10.0.2.99
52-54-00-71-75-11
**Адрес отправителя   Адрес получателя**
**192.168.1.1         10.0.2.11**
**52-54-00-71-75-11   4c-72-b9-e0-1f-62-fb**
На обратном пути адреса меняются.
До маршрутизатора: в адресе **получателя** указан MAC-адрес его интерфейса с внутренней стороны.
**Адрес отправителя   Адрес получателя**
**10.0.2.11           192.168.1.1**
**4c-72-b9-e0-1f-62   52-54-00-71-75-11**
После маршрутизатора: в адресе **отправителя** указан MAC-адрес его интерфейса со стороны нужной сети.
**Адрес отправителя   Адрес получателя**
**10.0.2.11           192.168.1.1**
**00-07-e9-5b-fb      7c-e9-d3-5f-8f-8f**

Таким образом:
На **сетевом уровне** IP-адреса в пакете сохраняются постоянными.
На **канальном уровне** MAC-адреса постоянно меняются.
Канальный уровень работает по принципу звеньев цепи:
Если получатель находится в другой сети и нет возможности передать данные ему напрямую, то в качестве MAC-адреса получателя указывается MAC-адрес маршрутизатора.

Вспомогательные средства, которые используются при передаче пакетов:
* Протокол ARP - извлечение MAC-адреса по IP.
* Маска подсети - для определения в нужной ли сети находится получатель и можно ли передать данные напрямую или нужно передать маршрутизатору
* Таблица маршрутизации - для извлечения данных по передаче шлюзу

# Transport layer

**Задачи транспортного уровня**
1. Передача данных между процессами на разных хостах.
2. Адресация.
Для какого именно процесса предназначен тот или иной пакет.
3. Предоставление нужного уровня надёжности передачи данных, независимого от надёжности сети.

В модели OSI отдельно выделяются:
**хосты**, в нашем случае устройства, где работают полезные пользовательские программы
**сетевое оборудование** - маршрутизаторы, коммутаторы, иные сетевые адаптеры.

На сетевом уровне в OSI есть только три канала:
Физический, Канальный, Сетевой.
Уровни, начиная с **транспортного** работают только на хостах.

Особенностью транспортного уровня является прямое взаимодействие с транспортным уровнем другого хоста.
На остальных уровнях взаимодействие ведётся по так называемым **звеньям цепи**.
(См. пример строки 2112G (vim)).
Транспортный уровень обеспечивает сквозное соединение между двумя взаимодействующими хостами. Между ними может находиться большое количество сетевых устройств, но они не влияют на работу транспортного уровня.
Поэтому транспортный уровень называют **сетенезависимым**.

**Адресация**
Для адресации на транспортном уровне используются **порты**.
Адрес на транспортном уровне - это число от 1 до 65535.
Адрес называется **портом**.
Каждое сетевое приложение на хосте имеет свой порт.
Номера портов у приложений не повторяются.
Иначе мы не сможем понять какому конкретно процессу отправить пришедший пакет.
Форма записи:
192.168.1.3:80

**Типы портов**.
**Хорошо известные порты: 1-1024**
* 80 - HTTP (Web)
* 25 - SMTP (Электронная почта)
* 53 - DNS
* 67, 68 - DHCP
* Использовать может только root/Администратор
**Зарегистрированные порты: 1025-49151**
* Регистрация в Internet Assigned Numbers Authority (IANA)
**Динамические порты: 49151-65535**
* Автоматически назначаются операционной системой сетевым приложениям.

**Надёжность на транспортном уровне**
Важной особенностью транспортного уровня является то, что он может обеспечить надёжность передачи данных большую, чем у лежащей на его основе сети.

**Гарантия доставки данных**:
* Подтверждение получения
* Повторная отправка не подтверждённых данных

**Гарантия порядка следования сообщений**:
* Нумерация сообщений

В стеке протоколов TCP/IP на транспортном уровне используются два протокола: TCP и UDP.

Итого:
транспортный уровень - обеспечивает связь процессов на разных хостах.
Его интерфейс - сокеты.

# protocol UPD

**User Datagram Protocol (UDP)** - протокол дейтаграмм пользователя.
Сообщение UDP называется **дейтаграмма**
(Аналогия с телеграммой).

**Особенности UDP**
* Нет соединения
* Нет гарантии доставки данных
* Нет гарантии сохранения порядка сообщений

**Надёжность** доставки по сравнению с IP не повышается.

**Формат заголовка UDP**
16 бит                  16 бит
Порт отправителя    Порт получателя
16 бит                  16 бит
Длина UDP           Контрольная сумма UDP
**Длина UDP**:
* Минимум восемь байт (только заголовок)

**Применение UDP**
Преимущество UDP - **скорость работы.**
* Нет накладных расходов на установку и разрыв соединения

**Надёжность**
* В современных сетях ошибки происходят редко
* Ошибку может обработать само сетевое приложение

**Область применения**
* Клиент-сервер
* Короткие запросы-ответы

В качестве примера можно рассмотреть DNS.
Позволяет определить по доменному имени IP-адрес
Например, www.cisco.com -> 184.86.0.170
Использует UDP, порт 53.
В результате работы протокола UDP получается всего 2 сообщения:
1. Клиент DNS делает запрос: "Какой IP у www.cisco.com?"
2. Сервер DNS отвечает "184.86.0.170"2. Сервер DNS отвечает "184.86.0.170"

Примеры решения с проблемами UDP:
приложение клиента вместе с отправкой первого запроса запускает таймер.
По истечению этого таймера предпринимаются прописанные меры, например, отправляется второй запрос.

Итог:
Основная задача - указать порты отправителя и получателя.

# Protocol TCP

**TCP (Transmission Control Protocol**, протокол управления передачей) – протокол транспортного уровня стека TCP/IP.
Примерный перевод - протокол управления передачей.

**Сервис TCP**
* **Надёжная** передача потока байт (reliable byte stream).

**Гарантии TCP**:
* Доставка данных.
* Сохранения порядка следования сообщений.

**Поток байт**
От приложения протокол TCP получает поток байт, который может быть очень большим (пример - скачивание фильма на торрент).

-----------------------------------------
| Сегмент | Сегмент | Сегмент | Сегмент |
-----------------------------------------
Транспортная подсистема получает от приложения данные в виде потока байт.
Поток разбивается на отдельные части, которые называются **сегменты**.
Каждый сегмент отправляется отдельно.
Сегменты передаются от отправителя к получателю независимо друг от друга.
**Получатель** принимает сегменты, собирает их в один большой поток байт и передает его принимающему приложению.

Для гарантии доставки TCP использует подтверждение получения данных.
Получатель, после приема очередной порции данных, передает отправителю подтверждения о получении.
(Acknowledgement, ACK).
В случае, если подтверждение не пришло, отправитель передает данные еще раз.

В TCP подтверждается не получение каждого сегмента, а получение нескольких сегментов. Это сделано для увеличения скорости передачи данных: отправитель может передать без остановки несколько сегментов, не дожидаясь прихода подтверждения.
Такой тип подтверждения называется **кумулятивный**: подтверждается получение последнего сегмента и всех предыдущих.
Количество сегментов, которые отправитель может передать без подтверждения, называется **размер скользящего окна**.

**Порядок следования сообщений**
Подтверждения и повторной отправки недостаточно для надежной передачи потока байт.
* Необходима зашита от потери сегментов.
Однако в дополнение к потере данных возможна и другая проблема: нарушение порядка следования сообщений:
* Сегменты приходят в неправильном порядке.
* Сегменты дублируются.
(Например, когда передача ACK не была получена отправителем).

**Порядок следования сообщений**
Для сохранения порядка следования сообщений используется нумерация сообщений.
Особенность протокола TCP в том, что он нумерует не сегменты, а байты в сегментах.
Нумерация сообщений позволяет расставить перепутанные сегменты в правильном порядке, а также не учитывать дублирующийся сегменты.

Механизм обеспечения сохранения порядка следования сообщений:
* Нумерация сообщений.

Поток байт от приложения:

------------------------------------------------
|  Сегмент |  Сегмент  |  Сегмент  |  Сегмент  |
------------------------------------------------
|  Байт 0  | Байт 1024 | Байт 2048 | Байт 3072 |
------------------------------------------------

Получатель отправляет ответ: "ACK, жду байт 1025" и т. д., указывая первый байт в сегменте.

**Соединение TCP**
Перед отправкой данных по TCP необходимо установить соединение. Задачи соединения:
* Убедиться, что отправитель и получатель хотят передавать данные друг другу.
* Договориться о нумерации потока байт.
Каждый раз начальное значение нумерации байт выбирается по определённому алгоритму.
Получатель и отправитель должны договориться между собой какое начальное значение они будут использовать для нумерации потока байт.
* Договорится о параметрах соединения (максимальный размер сегмента и т.п.).

После завершения передачи данных соединение TCP разрывается.

# Скользящее окно TCP
**Протокол TCP: Подтверждение доставки**.

**Гарантия доставки данных в TCP**:
* Подтверждение доставки
* Повторная отправка неподтверждённых сообщений

**Варианты подтверждения**:
* Остановка и ожидание (Wi-Fi, канальный уровень)
* Скользящее окно (TCP, транспортный уровень)

**Остановка и ожидание**:
Отправитель передаёт данные и останавливается, ожидая подтверждения.
Получатель присылает Подтверждение.
Повторить до упора.

Другой вариант: **скользящее окно**.
Отправитель отправляет несколько порций данных, не дожидаясь подтверждения.
Получатель отправляет Кумулятивное подтверждение.
Кумулятивное подтверждение означает, что получатель получил последнюю порцию данных и все предыдущие.

**Время передачи сообщения**
Сообщение передаётся не мгновенно:
* Время передачи короткое, но не нулевое

В среде может находиться некоторый объём данных:
* Скорость передачи данных * Задержка передачи данных
* Небольшой объём для локальных сетей
(отправитель и получатель рядом, задержка небольшая).
* Большой объём для широких территориально-протяжённых каналов.
(например, попытка скачать что-то из другой страны).

В последнем случае ожидание подтверждения приводит к снижению производительности.
Скорость канала в 10 Гб/c и задержка в 10 мс
Объем данных в сети: умножаем задержку на скорость передачи данных это составляет 12,5 МБайт.
Это означает, что отправитель начал передавать данные и до того как первая порция данных дойдет до получателя он может отправить в сеть 12,5 МБайт.
Ещё столько же он может отправить в сеть пока до него дойдёт подтверждение получения.
Если не останавливать передачу до получения подтверждения, можно передать в сеть 25 МБайт и только после этого получить подтверждение первой порции данных.

**Скользящее окно**.
**Размер окна** - количество байт данных, которые могут быть переданы без получения подтверждения.
Измеряется в количестве сегментов, которые могут быть отправлены.

Таким образом **поток байт** выглядит состоящим из трёх блоков:
**Отправленные данные** - то, что уже отправлено и получение чего подтверждено получателем.
**Скользящее окно** - то, что отправлено и ожидает подтверждения.
Имеет установленный размер.
**Неотправленные данные** - то, что ещё только предстоит поделить на сегменты и отправить.

Есть два типа подтверждения.
**Кумулятивное подтверждение**
* Подтверждение приёма указанного байта данных и всех предыдущих.
Используется по умолчанию.

Но сейчас, из-за распространения высокоскоростных каналов связи большой протяжённости, размер окна TCP может быть увеличен до 1 Гб.
Если при этом объёме данных окажется потерян хотя бы 1 сегмент в середине, и, например, подтвердить вы можете передачу только первых 500 Мбайт, то придётся передавать все 500 Мбайт данных повторно.

**Выборочное подтверждение (Selective Acknowledgment, SACK)**:
* Подтверждение диапазонов принятых байт
В таком случае отправитель, при пересланных 500 Мбайт передаст лишь один недостающий сегмент.
* Эффективно при большом размере окна
По умолчанию не используется, необходимо:
* Дополнительное поле заголовка TCP (параметр).

# Установка соединения

**Гарантии предоставляемые TCP**:
* Гарантия доставки
* Гарантия сохранения порядка следования сообщений

**Процесс передачи данных в TCP**:
**Установка соединения** (Трёхкратное рукопожатие)
**Передача данных**
**Разрыв соединения**

**Установка соединения**.
1. Отправитель посылает Запрос SYN (Synchronization).
Также в сообщение вкладывается порядковый номер передаваемого байта.
2. Получатель отправляет в ответ также передаёт сообщение SYN,
куда включает подтверждение получения предыдущего ACK и порядковый номер байта, который он ожидает.
Так же получатель включает в сегмент номер байта в потоке байт.
Пример:
SYN 7537
SYN 36829, ACK 7538
Номера байт в первом сообщении не могут быть всегда нулевыми, они выбираются по определённым алгоритмам.
3. Высылается ACK подтверждение на установку предыдущего соединения и номер следующего ожидаемого байта (в оном примере 36830) и номер байта в сообщении (7538).

**Передача данных**.

**Разрыв соединения**.
Соединение в TCP **дуплексное**:
* Данные могут передаваться в обе стороны

**Схема разрыва соединения**:
* Одновременное (обе стороны разорвали соединение)
* Одностороннее (одна сторона прекращает передавать данные, но может принимать)

**Варианты разрыва соединения**:
* Одностороннее закрытие (FIN)
* Разрыв из-за критической ситуации (RST)

**Корректное закрытие соединения**:
1. Инициатор: FIN
2. Получатель: ACK
В данном случае соединение разорвано односторонне: инициатор не может передавать данные получателю, но получатель инициатору разрыва соединения - может.

Когда получатель решает, что данные для передачи у неё закончились, она также передаёт сообщение FIN, получая в ответ ACK.

**Разрыв соединения в критической ситуации**
Из-за ошибок в приложении или из-за оборудования, используется одно сообщение:
**RST** - в этом случае соединение закрывается в обе стороны.

# Формат заголовка TCP
                    32 бита
-----------------------------------------------------
|Порт отправителя             |  Порт получателя    |
-----------------------------------------------------
|                   Порядковый номер                |
-----------------------------------------------------
|                   Номер подтверждания             |
-----------------------------------------------------
|Длина    | |N|C|E|U|A|P|R|S|F|  Размер окна        |
|заголовка| |S|W|C|R|C|S|S|Y|I|                     |
|         | | |R|E|G|K|H|T|N|N|                     |
-----------------------------------------------------
|Контрольная сумма            |Указатель на срочные |
|                             |      данные         |
-----------------------------------------------------
|              Параметры (необязательно)            |
-----------------------------------------------------
|               Данные (необязательно)              |
-----------------------------------------------------

**Порты** - адреса на транспортном уровне.
**Порядковый номер** - нумерация сегментов в потоке байт.
**Номер подтверждения** - функционал гарантии доставки сообщения.
Используется для задания кумулятивного подтверждения. Указывается номер последнего полученного байта +1. (Номер следующего ожидаемого байта)
**Длина заголовка** - указывает сумму длин обязательного и необязательного заголовков.
Затем 3 зарезервированных байта.
3 флага - для управления перегрузкой.
URG - срочные данные (совместно с полем "Указатель на срочные данные", но сейчас (2021-ый) не используется).
ACK - для подтверждения ранней информации - совместно с полем "Номер подтверждения".
PSH - полученные данные необходимо сразу передать приложению, без промежуточной записи в буфер (сейчас не используется).
**Размер окна** - получатель указывает сколько данных он может принять. Поле используется для управления потоком байт.

**Параметры**.
**Максимальный размер сегменты** (Maximum Segment Size, MSS)
сегмент какого размера может принять получатель. Зависит от формата кадров типа Ethernet.
Задаётся при установке соединения.
**Масштаб окна** - позволяет увеличить размер окна до 1 ГБ, что эффективно для быстрых каналов.
**Выборочное подтверждение** (Selective Acknowledgment, SACK) - подтверждение диапазонов принятых байт
**Метки времени**.

# Управление потоком

В сети могут быть устройства разной производительности.
**Управление потоком (flow control)** - это предотвращение "затопления" медленного получателя быстрым отправителем.
Для этой цели используется поле **Размер окна**.
В этом поле получатель указывает сколько байт данных он может принять.
Например:
в Подтверждении (ACK), помимо номера следующего ожидаемого байта указывается размер окна.
Всего 8 ячеек буфера.
1. Байт 1000 (до 2459) - записана одна ячейка буфера у Получателя
2. ACK, 2460, размер окна 10220 - Получатель передаёт что прямо сейчас 7 ячеек свободны.
7 * 1460 = 10220 -> размер окна 7 сегментов. (Пример с Ethernet)
1460 + 20 (Header TCP) + 20 (Header IP) = 1500
3. Отправитель передаёт 4 сегмента.
4. Получатель отправляет ACK, 8300, размер окна 4380
3 * 1460 = 4380 -> последние 3 ячейки буфера осталось.

Если отправитель полностью заполняет буфер, и ему приходит размер окна 0,
то он запускает таймер и ждёт следующих сообщений.
Далее **приложение** читает часть данных из буфера.
Тогда **получатель** снова отправляет номер следующего ожидаемого байта и указывает освободившийся **размер окна**.
ACK, 12680, размер окна 2920.
2 * 1460 = 2920

Если **отправитель** ждёт слишком долго, он может выслать **Zero Window Probe** - просьба подтвердить, что размер окна всё ещё равен нулю.
Он передаётся, чтобы убедиться, что получатель всё ещё остаётся на связи и не произошло каких-то ошибок.

# Управление перегрузкой

Возможна ситуация, когда в буфере получателя достаточно свободного места, но каналы связи, через которые передаются данные, сильно загружены.
Маршрутизаторы не способны передавать такое количество данных и вынуждены отбрасывать часть пакетов.
Отправитель посылает большое количество данных, однако большая часть этих данных не доходит до получателя.

**Коллапс перегрузки**
Коллапс перегрузки в Интернет (**congestion collapse**)
* Был теоретически предсказан в 1984, произошёл в 1986 г.
* Каналы связи загружены полностью
* Скорость передачи данных между хостами падала на порядок

**Решение**
* Учёт загрузки сети при определении размера окна
* Традиционный подход: фиксированное окно 8 сегментов
* Предложенный подход: размер окна динамически меняется в зависимости от нагрузки на сеть
* Механизм реализации: окно перегрузки

Таким образом было принято 2 реализации:
**Окно управления потоком** - задаётся получателем, указывает свободный буфер.
**Окно перегрузки** - рассчитывается на стороне отправителя в зависимости от того, какая нагрузка на сеть.

**Управление скоростью передачи в TCP**

**Маленький размер окна**
* Сегментов в сеть отправляется мало, не полностью используется пропускная способность сети
* Низкая скорость передачи данных
**Большой размер окна**
* Сегментов в сеть отправляется слишком много, происходит перегрузка и маршрутизаторы отбрасывают пакеты
* Низкая скорость передачи данных
Необходим способ определения оптимального размера окна.

**Additive increase/multiplicative decrease**
В TCP для определения окна перегрузки используется метод **аддитивного увеличения, мультипликативного уменьшения**.
**AIMD**

w(t + 1) = w(t) + a (если нет перегрузки).
a - как правило размер одного сегмента. См. ниже.
w(t + 1) = w(t) * b (если есть перегрузка).

Типовые параметры:
* a = максимальный размер сегмента MSS
* b = 1/2 от размера окна.

**Сигнал о перегрузке**
* Потеря сегмента
считается что сейчас каналы связи уже хорошего качества, а потому если сегмент потерялся, то это не ошибка канала связи, а из-за перегрузки сети.
* Задержка сегмента
* Сигнал от маршрутизатора: **Explicit Congestion Notification**

**Медленный старт**
Проблема AIMD - медленный (линейный) рост размера окна перегрузки
* Приемлемо на медленных каналах
* Неприемлемо на быстрых надёжных каналах
Медленный старт - альтернативный метод управления размером окна перегрузки:
* Первоначально размер окна перегрузки устанавливается маленьким (1 или 4 сегмента)
* При каждом получении подтверждения отправляется 2 сегмента
* Экспоненциальный рост размера окна
Недостаток:
* После сигнала о перегрузке начинаем с начала

В TCP используется комбинация медленного старта и AIMD:
Сперва используется **Медленный старт**, для того, чтобы быстро заполнить доступную пропускную способность канала.
Затем - после достижения определённого значения (**порог медленного старта**) - происходит переход на AIMD.

**Порог медленного старта** - определяется следующим образом: он работает до тех пор, пока не поступит сигнал о перегрузке.
После этого размер окна делится в два раза и это значение выбирается **порогом медленного старта**.

**Проблемы сигнала "потеря сегмента"**

**TCP создаёт перегрузку**
* Размер окна постоянно увеличивается
* Окно начинает уменьшаться только после того, как перегрузка произошла
поэтому предотвратить перегрузку при такой схеме нельзя.

**Глобальная синхронизация TCP (TCP global synchronization)**
* Место в буфере маршрутизатора заканчивается, он отбрасывает все новые сегменты
* Отправители получают сигнал о перегрузке и уменьшают размер окна
* Передача данных начинается всеми отправителями почти одновременно
В TCP не встроена функция рандомизированной задержки, в отличие от Ethernet.

**Способы решения**

**Задержка сегмента**
Происходит измерение **Round Trip Time**
Это время, которое требуется для отправки пакета данных в пункт назначения и время, которое требуется для подтверждения того, что этот пакет был получен обратно.
Отправитель измеряет среднее RTT и если он увеличивается, то он **уменьшает размеры окна перегрузки**.

**Проблемы сигнала "задержка сегмента"**
**"Несправедливость" на загруженных каналах**.
* Размер окна уменьшается при задержке сегмента, а другие отправители уменьшают только при потерях сегмента.

**Решение**
* Совместное использование сигналов задержка и потеря сегментов.
Пример: Compound TCP компании Microsoft.

Ещё один вариант, как отправитель может узнать о перегрузке - сигнал от маршрутизатора.
* Random Early Detection
Маршрутизатор с некоторой вероятностью начинает отбрасывать пакеты ещё до того, как буфер полностью заполнен и началась перегрузка.
В результате отправители узнают о возможной перегрузке по потере сегмента ещё до того, как перегрузка произошла, получая возможность заранее уменьшить окно перегрузки.
* Explicit Congestion Notification
Явный сигнал от маршрутизатора отправителю о том, что в сети происходит перегрузка.
1. Маршрутизатор, понимая, что буфер заканчивается, ставит в проходящий транзитом пакет отправителя флаг о перегрузке.
2. Получатель устанавливает соответствующие флаги в заголовке пакета, когда передаёт подтверждение.
3. Отправитель, видя эти флаги, уменьшает окно перегрузки.


**Формат заголовка IP-пакета**
|------------------------------------------------------------
|4 бита |4 бита    | 8 бит  | 00 |          16 бит          |
|Номер  |Длина     | Тип    |    |      Общая длина         |
|версии |заголовка | сервиса| 11 |                          |
|------------------------------------------------------------
|       16 бит                   |3 бита |      13 бит      |
|Идентификатор пакета            |Флаги  |Смещение фрагмента|
|------------------------------------------------------------
|   8 бит          |    8 бит    |      16 бит              |
|   Время жизни    |Тип протокола|  Контрольная сумма       |
|------------------------------------------------------------
|                       32 бита                             |
|                 IP-адрес отправителя                      |
|------------------------------------------------------------
|                       32 бита                             |
|                 IP-адрес получателя                       |
|------------------------------------------------------------
|                 Опции и выравнивание                      |
|                   (не обязательно)                        |
|------------------------------------------------------------

В поле **тип сервиса**:
00 - перегрузки нет
11 - произошла перегрузка


**ECN в заголовке TCP**

-----------------------------------------------------
|Порт отправителя             |  Порт получателя    |
-----------------------------------------------------
|                   Порядковый номер                |
-----------------------------------------------------
|                   Номер подтверждания             |
-----------------------------------------------------
|Длина    | |N|C|E|U|A|P|R|S|F|  Размер окна        |
|заголовка| |S|W|C|R|C|S|S|Y|I|                     |
|         | | |R|E|G|K|H|T|N|N|                     |
-----------------------------------------------------
|Контрольная сумма            |Указатель на срочные |
|                             |      данные         |
-----------------------------------------------------
|              Параметры (необязательно)            |
-----------------------------------------------------
|               Данные (необязательно)              |
-----------------------------------------------------

**ECE** (ECN-Echo) - устанавливается получателем при получении сигнала о перегрузке от маршрутизатора.
**CWR** (Congestion Window Reduced) - устанавливается отправителем для подтверждения получения сигнала о перегрузке.
**NS** (ECN-nonce concealment protection) - защита от случайного или злонамеренного изменения флагов ECN.

# Sockets

Сокеты - это интерфейс для взаимодействия с транспортным уровнем.
В отличие от протоколов транспортного уровня TCP и UDP, которые используются для связи между транспортными уровнями разных хостов, интерфейс сокетов используется для взаимодействия приложения с транспортным уровнем внутри одного компьютера.

Интерфейс сокетов был впервые предложен в Berkeley UNIX 4.2 BSD.
Сокет в UNIX - это файл специального вида.
Всё, что записывается в этот файл, передаётся по сети.
Передача данных по сети скрыта от программиста.

Сокеты - де-факто стандарт интерфейсов для транспортной подсистемы.
Сокеты оказались удобным интерфейсом, поэтому различные варианты сокетов реализованы в разных операционных системах (в том числе в Windows и Linux) и языках программирования.

**Операции сокетов Беркли**:
Тип операции **Создание сокетов**.
**socket** - создание нового сокета
**bind** - установка связи сокета с IP-адресом и портом
**listen** - объявление о желании принимать соединения
Тип операции **Установка соединения**.
**accept** - прием запроса на установку соединения
**сonnect** - установка соединения
Тип операции **Передача данных**.
**send** - отправка данные по сети
**receive** - получение данные из сети
Тип операции **Закрытие соединения**.
**close** - закрытие соединения

**Модель клиент-сервер**
Взаимодействующие стороны сокетов Беркли - клиент-сервер.
**Сервер** - работает (слушает) на известном IP-адресе и порту и пассивно ждёт запросов на соединение.
**Клиент** - активно устанавливает соединение с сервером на заданном IP и порту.

1. На сервере выполняется вызов **socket**
Создаётся объект сокет (в простейшем случае - просто файл).
2. Вызывается метод **bind**
Используется для присоединения объекта к определённому IP-адресу и порту.
3. Вызов **listen**
Сокет готов принимать соединение по сети.
Создаётся **очередь для соединений**.
В вызове необходимо указать размер этой очереди.
Если сервер получит больше, чем указанное число запросов на соединение, а предыдущие ещё не будут обработаны, то все новые запросы будут отбрасываться.
4. Сервер вызывает метод сокета **Accept**
Сервер готов принимать соединения и переходит в режим пассивного ожидания,
ждёт запросов на установку соединений от клиентов.

1. Клиент со своей стороны также вызывает метод **socket**.
Номер порта обычно назначается операционной системой.
Поэтому метод **bind** на клиентском сокете обычно не вызывается.
2. Вызывается метод **connect**.
В параметрах указываются IP-адрес и порт сервера.
Отправляется запрос на соединение.
В этот момент, для того, чтобы другие клиенты на этом же IP-адресе и порту сервера могли создавать соединение, **создаётся копия сокета**.
Поэтому соединение устанавливается не с исходным сокетом, а с копией сокета и данные передаются уже через копию сокета.
3. Клиент подготавливает порцию данных и вызывает метод **send**.
4. Данные передаются по сети и сервер может их прочитать с помощью метода **receive**.
Сервер и клиент могут обмениваться между собой порциями данныхю
5. После чего клиент вызывает метод **close**.

Программист взаимодействует с транспортным уровнем через интерфейс сокетов, поэтому протоколы TCP и UDP скрыты от программиста. Следовательно, при изменении протоколов транспортного уровня программу менять не придется.

# Services, interfaces, protocols

**Базовые понятия компьютерных сетей**
**Сервис** – описывает какие функции реализует уровень
**Интерфейс** – набор примитивных операций, которые нижний уровень предоставляет верхнему
**Протокол** – набор правил и соглашений, используемые для связи уровня N одного компьютера с уровнем N другого компьютера

Примеры для транспортного уровня:
* Протоколы: TCP и UDP.
* Интерфейс: сокеты.
* Сервисы: надежная передача потока байт и ненадежная передача коротких сообщений.

Разделять протоколы и интерфейсы необходимо для изоляции решений.
Это общий принцип проектирования в IT: описание и реализация должны быть отделены друг от друга.

**Разделение интерфейса и протокола**
Изоляция решений может быть реализована как внутри одного компьютера, так и при взаимодействии компьютеров друг с другом по сети.
**Внутри одного компьютера**
* Взаимодействие по протоколам, которые постоянны
* Интерфейсы внутри различных компьютеров могут сильно отличаться друг от друга
Реализация сетевого взаимодействия скрыта от нас, поэтому если протоколы изменяться программу менять нет необходимости.

**Между компьютерами**
* Взаимодействие по протоколам, которые постоянны
* Интерфейсы внутри различных компьютеров могут сильно отличаться друг от друга
За счёт этого обеспечивается возможность взаимодействия друг с другом по сети разных устройств, использующих разные ОС и значительные внутренние различия внутри программ.

**Разделение интерфейса и сервиса**
**Сервис** - это абстрактное описание того, что делает уровень.
Оно позволяет сформулировать, что требуется от уровня, не вдаваясь в детали реализации.

**Сервисы транспортного уровня TCP/IP**
* Надёжная передача потока байт (реализуется протоколом TCP)
* Ненадёжная передача коротких сообщений (реализуется протоколом UDP)

**Интерфейс** - это конкретное описание методов, процедур и функций, которые нужно вызвать, чтобы получить доступ к сервису.
Иными словами, - **сервис** - это набор операций для доступа к сервису.

**Интерфейс транспортного уровня** - это сокеты.
Через **один** этот **интерфейс** можно получить **доступ к двум типам сервиса**.
Для этого при создании сокета нужно указать разные константы (в Python socket.SOCK_STREAM или socket.SOCK_DGRAM).

В TCP/IP отсутствует сервис надежной доставки коротких сообщений.
Многим приложениям, например, службе имен DNS, приходится самим реализовывать эту функциональность.

# Network Address Translation
Трансляция сетевых адресов (NAT).
NAT - это технология преобразования IP-адресов внутренней (частной) сети в IP-адреса внешней сети (Интернет).
Цель создания – преодоление нехватки адресов IPv4.

**Внешние и внутренние IP-адреса**
**Внешние IP-адреса**
* Применяются в сети Интернет
* Должны быть уникальными
* Распределяются ICANN
* Адресов IPv4 не хватает для всех устройств в Интернет (количество адресов IPv4 примерно 4 млрд.)

**Внутренние IP-адреса**
* Диапазон частных сетей (RFC 1918): 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16
* Не маршрутизируются в Интернет
* Могут использоваться без обращения в ICANN
* Допускается использование одинаковых адресов в разных сетях (т. к. они не будут видны в Интернет)

**Типы NAT**:
**Статический NAT** - отображение один к одному.
Необходимо иметь столько же внешних IP-адресов, сколько и компьютеров во внутренней сети.
Как правило используется при подключении сети одной организации к сети другой организации.
**Динамический NAT** - отображение внутренних адресов на группу внешних адресов.
(Несколько внешних IP-адресов, которые по очерёдности используются внутренними адресами).
**Один ко многим (masquerading)** One-to-many - отображение внутренних адресов на один внешний адрес.

**Таблица NAT**
Преобразование выполняется с помощью таблицы NAT.
Таблица использует комбинацию IP-адрес + порт.
Вид таблицы NAT:

---------------------------------------------------------------
|Внутренний IP | Внутренний порт |  Внешний IP | Внешний порт |
---------------------------------------------------------------
|192.168.1.2   |      50300      |184.86.48.128|    49127     |
---------------------------------------------------------------
|192.168.1.3   |      52001      |184.86.48.128|    49128     |
---------------------------------------------------------------
|192.168.1.4   |      49238      |184.86.48.128|    49129     |
---------------------------------------------------------------

Устройство NAT при получении запроса от устройства из внутренней сети, записывает в таблицу его внутренний IP и сгенерированный внутренний порт и **генерирует пару внешний IP-адрес, внешний порт** для замены в пакете.
Далее происходит трансляция: IP-адрес и порт отправителя удаляются из пакета и на их место записываются внешняя пара из таблицы NAT.
В таком виде запрос приходит по адресу.
При получении ответа, в таблице NAT происходит поиск записи с соответствующими внешним IP и портом, после чего происходит замена данных в пакете на адрес и порт получателя их внутренней пары IP и порта.

**Преимущества NAT**:
* Позволяет преодолеть нехватку адресов IPv4.
* Легко развернуть и использовать.
* Скрывает структуру сети от внешнего мира.
**Недостатки NAT**:
* Нарушение фундаментального принципа построения IP-сетей: каждый компьютер может соединиться с любым другим.
Из-за этого рушатся протоколы, построенные по этому фундаментальному принципу.
* Нет возможности подключиться к компьютерам во внутренней сети из внешнего мира.
* Плохо работают протоколы, не устанавливающие соединения.
* Некоторые прикладные протоколы работают неправильно (FTP).
(два соединения: одно для управления, другое для передачи данных).
* Нет единого стандарта NAT, много разных вариантов.

**Решение проблем с NAT**
**Статическое отображение IP-адресов**:
* Внутренний IP <-> Внешний IP
* Требуется несколько внешних IP-адресов

**Статическое отображение портов**:
* Порт 80 -> Внутренний адрес Web-сервера и порт 80
* Порт 25 -> Внутренний адрес почтового сервера и порт 25
* Порт 21 -> Внутренний адрес FTP сервера и порт 21
(Порты отображаются в соответствующие внутренние порты).
Есть один внешний IP-адрес, но разные порты отображаются в разные пары IP-адрес и порт во внутренней сети.

**Технология NAT Traversal**:
* Позволяет устанавливать соединение с компьютерами во внутренней сети
* RFC 3489 и другие варианты
* Используется VoIP приложениями (Skype, etc).

# Firewall, Brandmauer

**Принцип проектирования сетей TCP/IP**
* Каждый компьютер может соединиться с любым другим компьютером в сети
Но на данный момент, из-за наличия злоумышленников сети появились новые требования к **безопасности**

**Межсетевой экран** - это устройство или программная система, предназначенные для отделения сетей друг от друга.
(Брандмауэр в Windows, iptables in linux, etc).
Межсетевые экраны находятся на:
сетевом и транспортном уровне в модели **OSI**,
Интернет и транспортном в модели **TCP/IP**.

Межсетевые экраны анализируют заголовки пакетов протоколов этих уровней. В основном они анализируют IP адрес отправителя и получателя и порты транспортного уровня, а также флаги и состояние соединения.
Межсетевые экраны перехватывают все пакеты, которые поступают в сеть, и проверяют их на соответствие политике безопасности по таблице правил.
Если находит разрешающее правило - передаёт дальше. В противном случае пакет отбрасывается.

**Таблица правил доступа**
Основные поля: отправитель и получатель, протокол и действие.
Пример:

-------------------------------------------------
|Отправитель|Получатель |Протокол|Флаг|Действие |
-------------------------------------------------
| IP  |Порт | IP  |Порт |        |    |         |
-------------------------------------------------
|Любой| 80  |Любой|>1024|   TCP  |Ack |Разрешить|
-------------------------------------------------

Межсетевой экран рассматривает таблицу правил последовательно от верхней позиции к концу таблицы.
Преимуществом использования межсетевых экранов является увеличение безопасности.
Например, в случае массированной атаки, он может проверять установлено ли соединение у входящих пакетов и запросов.

Помимо межсетевых экранов есть **другие методы ограничения доступа**.
**Канальный уровень**
* Фильтрация на портах коммутатора по MAC-адресам

**Прикладной уровень**
* Прокси-сервер (proxy server)
Делает то же, что и межсетевой экран, но на уровне прикладных протоколов.
Например, web proxy server:
перехватывает все ваши запросы на доступ к сайтам интернет,
соединяется с ними от своего имени,
получает ответ,
анализирует его и
пересылает вам.
Web proxy может запрещать доступ к сайтам по их адресам, например, доступ к социальным сетям с рабочих мест.
* Фильтр содержимого (content filter)
Анализирует не только заголовки, но и содержимое.

Система обнаружения вторжений (intrusion detection system, IDS)
Система предотвращения вторжений (intrusion prevention system, IPS)
Работают по принципу похожему на межсетевые экраны, но анализируют не отдельные пакеты, а последовательности пакетов.

**Недостатки межсетевых экранов**:
* Неправильная конфигурация может привести к неработоспособности сети.
* Возможно снижение производительности сети.

**Прикладной уровень** - самый верхний уровень моделей OSI и TCP/IP.
Протоколы прикладного уровня используются для взаимодействия и связи между различными сетевыми приложениями.
В стек TCP/IP входят следующие протоколы прикладного уровня:
* протокол передачи Web-страниц HTTP (Hypertext Transfer Protocol)
* протоколы электронной почты SMTP, POP3 и IMAP
* протокол системы доменных имен DNS (Domain Name System)
* протокол передачи файлов FTP (File Transfer Protocol)
* и многие другие
Не стоит путать сетевые приложения и сетевые протоколы.
Сетевые приложения могут для своей работы использовать несколько сетевых протоколов, например, web browser может использовать DNS и HTTP.

В стеке протоколов TCP/IP прикладной протокол должен реализовывать функции сеансового уровня и уровня представления модели OSI, если они ему нужны.
**Функции сеансового уровня**
**Сеанс** (сессия) - это набор связанных между собой сетевых взаимодействий, направленных на решение одной задачи.
Загрузка Web-страницы:
* Загрузка текста страницы (.html)
* Загрузка стилевого файла (.css)
* Загрузка изображений
Таким образом для того, чтобы загрузить одну Web-страницу, необходимо выполнить несколько отдельных сетевых операций.
Набор таких операций и называется **сеансом**.
В логике модели OSI это должно выполняться на **сеансовом уровне**, но в логике TCP/IP этим должно заниматься само приложение.

**Подходы к загрузке Web-страницы**:
* Для каждого элемента создаётся отдельное соединение (HTTP 1.0)
* Загрузка всех элементов через одно соединение TCP (HTTP keep-alive)

**Функции уровня представления**

Для защиты передаваемых по сети данных часто используется шифрование:
* Secure Sockets Layer
* Transport Layer Security

Протоколы, которые используют TSL/SSL:
* HTTPS, порт 443
* IMAPS, порт 993
* SMTPS, порт 465
* FTPS

Протокол HTTP использует HTTP keep-alive для загрузки различных элементов Web-страницы (гипертекста, стилевого файла, картинок и т.п.) через одно соединения TCP для увеличения производительности (функция сеансового уровня).
Протокол HTTPS использует технологии TLS/SSL для шифрования передаваемых по сети данных в целях безопасности (функция уровня представления).

Некоторые современные сетевые устройства работают на прикладном уровне. Например, контент-фильтр, который может ограничивать доступ к некоторым Web-страницам. Для этого контент-фильтр просматривает HTTP трафик, анализирует адреса, к которым обращается пользователь, и блокирует доступ к запрещенным адресам и доменам.

# DNS

Система DNS предназначена для отображения символьных доменных имен компьютеров в IP-адреса.
Позволяет по символьному имени определить ip-адрес.

**Преимущества DNS**:
* Понятные человеку имена
* Возможность менять сетевую инфраструктуру

Узнать ip адрес по доменному имени можно утилитой **nslookup**.
> nslookup www.yandex.com

Server:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
Name:	yandex.com
Address: 77.88.55.77
Name:	yandex.com
Address: 5.255.255.80
Name:	yandex.com
Address: 5.255.255.88
Name:	yandex.com
Address: 77.88.55.80
Name:	yandex.com
Address: 2a02:6b8:a::a

Ещё одно преимущество DNS - если на наш сервер обращается большое количество клиентов, которое один компьютер обработать не способен, мы можем создать несколько серверов и в систему DNS прописать, что наш домен обслуживает несколько серверов.

**До использования системы DNS**
Файл /etc/hosts содержил имена компьютеров и их адреса

Пример:
102.54.94.97    server
38.25.63.10     my-client

**Недостатки**
* Быстро увеличивается размер
* Сложно вносить изменения
* Возможны конфликты имён, так как в разных организациях компьютеры называли одним и тем же именем.

**Особенности DNS**
При создании системы DNS было решено, что это принципиально децентрализованная система
как на техническом уровне:
**Распределённая система**
* Нет единого сервера, на котором описываются имена хостов
Так и на административном уровне:
**Делегирование ответственности**
* Пространство имён разделено на отдельные части - домены
* За каждый домен отвечает отдельная организация

**Надёжность**
* Дублирование серверов DNS

**Структура доменного имени**
Имя компьютера состоит из нескольких частей, которые отделены друг от друга точками.

Пример:
www.yandex.com
com - домен верхнего уровня
yandex - домен второго уровня
www - имя компьютера в домене второго уровня.

Корневой домен - точка в конце адреса (www.yandex.com.) - если её не указать, она подразумевается у каждого доменного имени.

**Дерево доменных имён**
Корневой домен
Домены верхнего уровня:
1. для различных типов организаций: com - коммерческие организации, org - некоммерческие организации, net - организации, связанные с компьютерными сетями)
2. для стран (ru, uk - United Kingdom)
org     com     net         ru  uk  рф
Домены второго уровня:
cisco   google              yandex
Домены следующего уровня (поддомены) или адреса компьютеров второго уровня.
                    www     maps    taxi

**Доменная зона** - запись адресов всех компьютеров и всех поддоменов в некотором домене.
Так, корневая доменная зона содержит записи всех доменов верхнего уровня (поддоменов первого уровня).
Зона com - содержит записи всех доменов второго уровня.
Зона yandex - содержит записи всех поддоменов и всех компьютеров в домене yandex.
Последние содержат записи об адресе конкретных компьютеров.

Так, доменная зона является некоторым аналогом файла /etc/hosts
Доменные зоны распределены по серверам DNS.
Одну и ту же доменную зону могут обслуживать несколько серверов DNS.

**Делегирование домена**.
Сервера DNS делегируют поиск нужных записей поддоменам.
Для этого делаются соответствующие конфигурационные записиб указывающие на DNS-сервер, ответственный за зону.

**Инфраструктура DNS**
Таким образом у нас есть **дерево серверов DNS**.
**Клиент DNS**.
(Например, компьютер, запрашивающий адрес).
**DNS resolver** - сервер разрешения имён, который получает запрос от клиента и выполняет поиск необходимого ip-адреса в дереве доменных имён.

**Распределение доменных имён**
Распределением доменных имён занимаются **регистраторы**
**Регистратор корневого домена один**
* Internet Corporation for Assigned Names and Numbers (ICAN)
**Регистраторы зон первого уровня**:
* Необходима аккредитация в ICANN
* Один или несколько регистраторов для каждой зоны
* Регистрируют домены второго уровня

# DNS protocol

**Режимы работы DNS**

**Итеративный**
* Если сервер отвечает за данную доменную зону - он возвращает ответ
* Если не отвечает, то возвращает адрес DNS-сервера, у которого есть более точная информация

**Рекурсивный**
* Сервер сам выполняет запросы к другим серверам DNS, чтобы найти нужный адрес

Два режима работы необходимы, потому что в систем DNS есть два типа серверов.
* DNS-сервера, которые хранят данные об отображении доменных имён в ip-адресах работают в итеративном режиме.
Так как к этим серверам (особенно корневому домену и доменам верхнего порядка) приходит очень много запросов и производительности для работы в рекурсивном режиме не хватает.
* Сервера типа DNS-resolver работают в рекурсивном режиме.

Как правило сервер разрешения имён (DNS resolver) предоставляется провайдером/организацией
* Компьютер получает адрес локального сервера DNS по DHCP

**Открытый сервер**
* Google: 8.8.8.8 и 8.8.4.4
* Яндекс: 77.88.8.8 и 77.88.8.7

После того как DNS-resolver нашёл ip-адрес для доменного имени, он записывает его в **кэш**.

**Типы ответов DNS**
**Авторитетный (authoritative,** "заслуживающий доверия")
* Ответ от сервера, обслуживающего доменную зону
* Получен из файлов на диске сервера

**Неавторитетный (non-authoritative,** "не заслуживающий доверия")
* Ответ от сервера, который не обслуживает доменную зону
* Получен из кэша, данные могли устареть.

Протокол DNS использует модель **клиент-сервер**, запрос-ответ.
DNS использует протокол UDP
* Номер порта 53

**Формат пакета DNS**
Состоит из заголовка и данных.

----------------------------------------
|Идентификатор  |       Флаги          | - заголовок
----------------------------------------
|   Количество  | Количество           |
|   запросов    |дополнительных ответов| 
----------------------------------------
|           Запросы DNS                | - данные
----------------------------------------
|           Ответы DNS                 |
----------------------------------------
|       Авторитетные серверы           |
----------------------------------------
|   Дополнительная информация          |
----------------------------------------

**Идентификатор** - любое целое число, одинаковое в запросе и ответе.
**Запросы DNS** - доменное имя, которое хотим узнать.
**Ответы DNS** - ip-адрес, который мы хотим узнать.
**Авторитетный сервера** - в итеративном режиме работы здесь указываются ip-адреса, имеющие информацию об интересующей нас доменной зоне.

Поле **флаги** состоит из нескольких полей.
QR - запрос (0) или ответ (1)
OPCODE (4 бита) - тип запроса,
* 0 - стандартный запрос
AA - авторитетный ответ (1) или нет (0)
TC - пакет был обрезан (1) или нет (0)
RD - запрос на рекурсивный режим
RA - рекурсивный режим доступен
Z - зарезервировано
RCODE (4 бита) - статус, 0 - успешно, другие коды - ошибка.

**Формат запроса DNS:**
Имя
Тип записи
Класс записи

Пример.
www.yandex.com
1 (A запись)
1 (IN, Интернет)

**Формат ответа DNS**:
Имя
Тип записи
Класс записи
Время жизни (TTL) - время, на которое данные можно сохранить в кэше DNS-resolver'a.
Длина данных
Данные

Пример.
www.yandex.com
1 (A запись)
1 (IN, Интернет)
90 (секунд)
4 (длина в байтах)
77.88.55.66

# Типы записей DNS

**Функционал DNS**

* Определять для доменного имени адреса IPv4 и IPv6
* Задавать несколько доменных имён для одного IP-адреса
* Находить адрес почтового сервера для домена
* Определять IP-адрес и порт некоторых сетевых сервисов
* Задавать адрес DNS-серверов для доменной зоны
* Определять по IP-адресу доменное имя.

Для реализации этих функций используются разные типы записей DNS.

**Тип записи DNS**
Каждая DNS запись (Resource Record, RR) имеет:
* **Тип записи** - для чего предназначена запись
* **Класс записи** - в каких сетях используется (IN - Интернет)

Типы записей для IP-адресов:
* A - адрес IPv4
* AAAA - адрес IPv6
* CNAME - псевдоним для доменного имени
MX - адрес почтового сервера
SRV - адреса и порты сетевых сервисов
NS - адреса DNS-серверов, ответственных за зону
PTR - доменное имя для IP-адреса

Запрос записей разных типов в утилите nslookup выполняется с флагом **-type**, пример:
nslookup -type=XXX yandex.com

Example:
nslookup -type=AAAA yandex.com
Server:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
Name:	yandex.com
Address: 2a02:6b8:a::a

**DNS псевдонимы**
Для одного и того же ip-адреса можно задавать несколько доменных имён.

1. **Запись типа CNAME** (Canonical Name Record/каноническая запись имени)
* Определяет псевдоним для другого доменного имени
Пример: ftp.asozykin.ru -> www.asozykin.ru

2. **Альтернативный способ:**
* Задать несколько A записей для одного IP-адреса.

Система DNS активно используется при работе электронной почты.
**Адреса почтового сервера**
Для того, чтобы узнать адрес почтового сервера используются записи типа **MX (Mail eXchange).**
Запись MX содержит два поля:
Приоритет   Адрес сервера
* 5 gmail-smtp-in.l.google.com
* 10 alt1.gmail-smtp-in.l.google.com
* etc.
Самый высокий приоритет у минимального значения.

**Адреса сетевых сервисов**
Для некоторых сервисов можно задавать не только IP-адреса, но и порты
* Jabber
* CIP
* Kerberos

**Запись типа SRV (Service record):**
* сервис.протокол.имя. -> приоритет вес порт имя
перед сервисом и протоколом - нижнее подчёркивание
* xmpp-server.tcp.example.com. -> 0 5 5269
xmpp.example.com
Вес используется для распределения нагрузки между разными серверами, имеющими один и тот же приоритет.

**Запись типа NS (Name Server)**
* Указывает адреса DNS-серверов, отвечающих за зону.
Записи типа NS задаются на домене более высокого уровня.

Примеры:
* yandex.com -> ns1.yandex.net
                ns2.yandex.net

Вышестоящий домен использует "приклеенные" A-записи, чтобы определить адреса серверов в NS-записях.

**Типы DNS-зон:**
**Прямая** - определение IP-адреса по доменному имени
**Обратная** (reverse) - определение доменного имени по IP-адресу

**Специальное доменное имя для обратных зон**:
* Домен для обратных зон in-addr.arpa.
* IP-адрес записывается в обратном порядке
* 77.88.55.66 -> 66.55.88.77.in-addr.arpa.

Реверсивная зона содержит **запись типа PTR (Pointer)**
* 66.55.88.77.in-addr.arpa. -> yandex.ru
Она ставит в соответствие ip-адрес компьютера его доменному имени.


# protocol HTTP

Hypertext Transfer Protocol (HTTP) – протокол передачи гипертекста, основа World Wide Web.
Тим Бернерс-Ли в ЦЕРН предложил концепцию Web в 1989 году.
Кроме протокола HTTP, концепция Web включала в себя:
* Язык гипертекстовой разметки страниц HTML
* Протокол передачи гипертекстовых страниц HTTP
* Web-сервер
* Текстовый web-браузер
(В ходу давно графический web browser).
Сейчас Тим Бернерс-Ли директор консорциума W3C.

Так же в концепции Web большую роль играет URL.
Uniform Resource Locator (URL) – уникальное положение ресурса.
Иными словами - уникальный адрес ресурса в интернете.
Формат URL:
1. Название протокола,
2. "://",
3. Доменное имя сервера, на котором размещён ресурс или ip-адрес сервера,
4. "/",
5. Имя страницы, которую мы хотим загрузить.
Пример:
https://habr.com/ru/companies/flant/articles/521406/

В стеке TCP/IP протокол HTTP находится на прикладном уровне.
Он использует протокол транспортного уровня TCP, WEB-сервер работает на 80 порту сервера.
HTTP работает в режиме запрос-ответ.
Клиент отправляет серверу запрос на передачу WEB-страницы,
Сервер пересылает в ответ запрашиваемую WEB-страницу.
Данные передаются в текстовом виде.

Версии протокола HTTP:
HTTP 0.9 – экспериментальная версия ЦЕРН, 1991
HTTP 1 – первая официальная версия протокола, 1996
HTTP 1.1 – расширение первой версии HTTP, 1997. Кэширование, постоянное соединение, аутентификация. Используется сейчас
HTTP 2 – современная версия HTTP, 2015. Вводится в эксплуатацию

Структура пакета HTTP:
* Метод запроса/статус ответа
Например:
GET https://habr.com/ru/companies/flant/articles/521406/
(   Scheme: https
    Host: habr.com
    Filename: /ru/companies/flant/articles/521406/
)
 - ответ сервера в виде статуса выполнения операции, кода и символьного сообщения.
Например:
200 OK
означает, что страница нашлась на сервере и он передаёт её в теле сообщения.
* Заголовки
Пример:
 - Host,
 реализовано потому, что на одном и том же ip-адресе, может работать несколько web-сайтов и серверу необходимо знать, с какого сайта вы хотите загрузить страницу.
 - Content-Type,
Пример: test/html; charset=UTF-8
 - Content-Length, etc.
* Тело сообщения (не обязательно)
 - Здесь передаётся запрашиваемая web-страница (страница HTML, etc).
 - Параметры, введённые пользователем.

Клиент при обращении к серверу указывает методы, которые он хочет использовать.
**Методы HTTP**:
GET – запрос Web-страницы
POST – передача данных на Web-сервер
HEAD – запрос заголовка страницы
PUT – помещение страницы на Web-сервер
DELETE – удаление страницы с Web-сервера
TRACE – трассировка страницы
OPTIONS – запрос поддерживаемых методов HTTP для ресурса
CONNECT – подключение к Web-серверу через прокси

**Статусы HTTP**:
В ответе сервера первое поле - это статус обработки запроса.
Они сгруппированы в 5 групп:
1XX – передача информационных сообщений
2XX – успешное выполнение (200 ОК)
3ХХ – перенаправление (301 – постоянное перемещение, 307 – временное перенаправление)
4ХХ – Ошибка на стороне клиента (403 – доступ запрещен, 404 – страница не найдена)
5ХХ – Ошибка сервера (500 – внутренняя ошибка сервера)

# keep-alive HTTP

Когда протокол HTTP 1.0 появился у него был простой функционал:
* Режим работы: запрос-ответ
* В основном размещались Простые текстовые документы

**Современные Web-страницы** держат куда более мощную нагрузку:
* HTML-страница
* Стилевой файл css
* Программы Java, Javascript
* Картинки (Видео и т. п. медиа)
* Блоки с других сайтов

Таким образом работа HTTP в современных условиях это загрузка большого количества ресурсов с Web-сервера.

Без постоянного соединения нужно постоянно запрашивать установку соединения TCP для каждого файла, а затем закрывать это соединение. Таким образом:
для самой web-страницы,
стилевого файла css,
изображений и т. д. требуются отдельные запросы на установку и разрыв соединения.

**Постоянное соединение HTTP**
(HTTP keep-alive, HTTP persistent connection) - использование одного TCP-соединения для загрузки нескольких ресурсов.

**Преимущества постоянного соединения:**
* Сокращение накладных расходов на установку TCP-соединения.
* Нет необходимости каждый раз начинать передачу данных с маленьким размером окна TCP (медленный старт).

В стандарте HTTP 1.0 возможности использовать постоянное соединение нет.
После публикации стандарта HTTP 1.0 был предложен заголовок "Connection: keep-alive".

Соединение при этом остаётся открытым
* Используется заголовок **Connection: keep-alive**
* Клиент и сервер поддерживают постоянное соединение
* Имеется достаточно ресурсов для сохранения соединения открытым

Пример использования заголовка "Connection: keep-alive":
HTTP-запрос:
GET /courses/networks HTTP/1.0
Host: www.asozykin.ru
Connection: keep-alive

HTTP-ответ:
HTTP/1.0 200 OK
Server: nginx
Content-Type: text/html; charset=UTF-8
Content-Length: 5161
Connection: keep-alive

В стандарте HTTP 1.1 по умолчанию все соединения постоянные.
Использование заголовка "Connection: keep-alive" необязательно, но многие браузеры и Web-серверы всё равно используют этот заголовок.
Можно явно попросить закрыть соединение:
* Connection: close

**Недостатки постоянного соединения**
Для поддержания соединения Web-серверу нужны ресурсы
* Если клиент открыл соединение и не использует его, то эти ресурсы недоступны другим клиентам
* Плохо для высоконагруженных серверов

**Автоматическое закрытие соединения**
* Таймаут 5-15 секунд.

**Другие способы ускорить загрузку страницы**
* Технология конвейерной обработки HTTP (pipelining) - отправка сразу нескольких HTTP запросов через постоянное соединение не дожидаясь ответа. Сервер также передает сразу несколько запрошенных ресурсов.

* Открытие сразу нескольких соединений с Web-сервером. Каждое такое соединение может быть постоянным и использовать конвейерную обработку.

# Кэширование в HTTP

Современные Web-браузеры поддерживают кэширование редко меняющихся ресурсов:
* Web-страницы
* Изображения (логотипы компаний, кнопки навигации и т. п.)
* Таблицы стилей
* Библиотеки Java Script
Это позволяет сократить время загрузки web-страниц, но для кэша требуется место на локальном диске компьютера.
Поддержка кэширования встроена в протокол HTTP.

Для определения, можно ли использовать копию ресурса из кэша, используются следующие методы:
1. **заголовок Expires**
Например:
* Expires: Sun, 12 Jun 2023 10:35:18 GMT // означает, что ресурс можно хранить до 12 июня
* По истечению даты ресурс запрашивается из источника
* Web-сервера не всегда устанавливают этот заголовок

2. **Эвристики:**
Также можно использовать эвристику на основе заголовка Last-Modified. Например:
* Last-Modified: Wed, 25 May 2023 05:12:24 GMT // поле, указывающее дату последнего изменения ресурса.
* Если страница долго не менялась, то скорее всего можно загрузить её из кэша
* Возможны ошибки

3. **Запрос GET с условием (Conditional GET)** – запрос Web-серверу передать ресурс, если он изменился с указанного времени.

Первый запрос ресурса с помощью GET:
* Ответ содержит заголовок Last-Modified // Conditional GET можно использовать только если в заголовке установлено поле Last-Modified
* Ресурс (данные из этого поля) записывается в кэш

Последующий запрос GET с условием:
* Ответ содержит заголовок If-Modified-Since
* If-Modified-Since: Wed, 25 May 2023 06:13:24 GMT

Ответы на запрос GET с условием:
* Ресурс не изменился: короткое сообщение со статусом 304 Not Modified.
Дополнительные заголовки: Expires, Last-Modified, Cache-Control
* Ресурс изменился: полная передача измененной версии ресурса, статус ответа 200 ОК.

4. **ETag в запросах GET с условием**
ETag (entity tag)
* Код, который генерируется на основе содержимого ресурса // как правило это хэш
* Заголовок ETag добавляется к HTTP ответу // web-сервером
* ETag: "57454284-3d8f" // пример
* При изменении содержимого ресурса меняется его ETag
* Появился в стандарте HTTP 1.1

ETag удобно применять, если web-сервер передаёт различные варианты одной и той же страницы (например, на разных языках).
В этом случае дату изменений использовать нельзя, т. к. страницы на разных языках могут быть изменены в одно и то же время.
Если необходимо использовать ETag в Conditional GET, то:
* Заголовок **If-None-Match** используется вместо If-Modified-Since
* If-None-Match: 57454284-3d8f

Таким образом подводя итоги:
Определение изменения ресурса в запросе Get с условием:
* По дате последнего изменения ресурса: заголовок If-Modified-Since (HTTP версия 1.0).
* По тэгу (хэшу) ресурса: заголовок If-None-Match (HTTP версия 1.1)

В HTTP версии 1.1 появился новый заголовок для управления кэшем Cache-Control.
* Пример: Cache-Control: private, max-age=10
* Появился в версии HTTP 1.1

Возможные значения:
* no-store // ресурс нельзя сохранять в кэш
* no-cache // ресурс сохранять в кэш можно, но для его использования необходимо выполнить запрос Conditional GET и загружать из кэша только, если он не изменился на сервере.
* public // информация может быть доступна всем, её можно кэшировать.
* private // страница может быть сохранена только в частном кэше браузера, но не в разделяемом кэше
* max-age=X (время в секундах) // время хранения в кэше

Кроме кэша браузера, ресурсы могут быть сохранены на прокси-серверах и обратных прокси-серверах.

**Прокси-сервер**
Данные web могут быть закэшированы не только в частном браузере, но и в прокси-сервере.
В этом случае клиенты обращаются к web-серверам не напрямую, а через прокси-сервер.
Прокси-сервер:
сам подключается к web-серверам в интернет,
получает ресурсы,
сохраняет их в разделяемый кэш
и потом передаёт клиентам.

Если большое число клиентов, работающих через этот прокси, часто обращаются к одним и тем же сайтам, то это позволяет значительно повысить скорость загрузки web-страниц.
(Так как необходимые ресурсы уже могут быть в разделяемом кэше).
С другой стороны пользователи ходят на большое количество разных сайтов и все эти ресурсы также записываются в разделяемый кэш прокси-сервера, хотя потом они используются очень редко или вообще не используются, что значительно снижает эффективность работы прокси-серверов.

Также есть **обратный прокси сервер (reverse proxy)**
Он устанавливается не со стороны клиентов, а со стороны web-серверов.
Обратный прокси-сервер принимает запросы от клиентов web-browser'ов из интернета и передаёт их на web-сервера.
При этом обратный прокси-сервер также кэширует ответы web-серверов, кэшируя не только статическую информацию, но и динамические страницы, которые получаются в результате работы программ на web-серверах.
Эти программы часто обращаются к базам данных или другим ресурсам и работают достаточно медленно.
Поэтому кэширование результатов работы этих программ в виде готовой web-страницы на обратном прокси-сервере существенно понижает скорость загрузки web-страниц.

# Email

Электронная почта (email) – технология передачи и получения электронных сообщений через компьютерную сеть.

Основные компоненты электронной почты:
Агент пользователя (MUA, Mail User Agent) - клиент электронной почты.
Агент передачи почты (MTA, Mail Transfer Agent) - программа передачи почты от клиента на сервер и между почтовыми серверами.
Агент доставки почты (MDA, Mail Delivery Agent) - программа записи сообщений в почтовые ящики получателей.

Адрес электронной почты состоит из двух частей: идентификатор пользователя и доменное имя. В качестве разделителя используется символ @ (коммерческая эт). Пример:
networkcourse@mail.ru.

Основные протоколы электронной почты:
**SMTP** – Simple Mail Transfer Protocol (используется для передачи сообщения как от MUA, так и от MTA).
Для чтения писем из хранилища сообщений используются два протокола:
**POP3** – Post Office Protocol 3 (передаёт все сообщения из хранилища сообщений на локальный компьютер пользователя и только после этого показывает их в агенте).
Удаляет из хранилища все письма, которые были доставлены пользователю.
**IMAP** – Internet Message Access Protocol (рассчитан на работу напрямую с хранилищем сообщений. Письма после прочтения пользователем не удаляются из хранилища).

Для определения почтового сервера получателя используется система DNS, запись типа MX (Mail eXchange).
Просмотр записей: **nslookup -type=mx gmail.com**


Server:		127.0.0.53
Address:	127.0.0.53#53

Non-authoritative answer:
gmail.com	mail exchanger = 20 alt2.gmail-smtp-in.l.google.com.
gmail.com	mail exchanger = 30 alt3.gmail-smtp-in.l.google.com.
gmail.com	mail exchanger = 10 alt1.gmail-smtp-in.l.google.com.
gmail.com	mail exchanger = 5 gmail-smtp-in.l.google.com.
gmail.com	mail exchanger = 40 alt4.gmail-smtp-in.l.google.com.

Authoritative answers can be found from:
alt2.gmail-smtp-in.l.google.com	internet address = 173.194.202.26
alt2.gmail-smtp-in.l.google.com	has AAAA address 2607:f8b0:400e:c00::1b
alt3.gmail-smtp-in.l.google.com	internet address = 142.250.141.26
alt3.gmail-smtp-in.l.google.com	has AAAA address 2607:f8b0:4023:c0b::1a
alt1.gmail-smtp-in.l.google.com	internet address = 142.250.157.27
alt1.gmail-smtp-in.l.google.com	has AAAA address 2404:6800:4008:c13::1b
gmail-smtp-in.l.google.com	internet address = 64.233.161.26
gmail-smtp-in.l.google.com	has AAAA address 2a00:1450:4010:c01::1b
alt4.gmail-smtp-in.l.google.com	internet address = 142.250.115.26
alt4.gmail-smtp-in.l.google.com	has AAAA address 2607:f8b0:4023:1004::1b


