# Прокси для сервисов
**Прямые прокси** управляют исходящим трафиком для повышения производительности и фильтрации запросов и обычно используются в качестве интерфейса между пользователями в локальных сетях и ресурсами в интернете.<br>
Прямые прокси обычно улучшают производительность, кешируя статический веб-контент, и обеспечивают некоторый уровень безопасности, предотвращая доступ пользователей к определённым категориям веб-сайтов.<br>
**Обратные прокси**, напротив, управляют входящим трафиком, поступающим из интернета в локальные сети. Они обычно используются для фильтрации HTTP-запросов, защиты и балансировки нагрузки на серверы.<br>
То есть прямые прокси служат олицетворением пользователей для внешних серверов, а обратные прокси - олицетворением реальных серверов для внешних пользователей (клиентов).<br>

Обычно в концепции разработки высоконадёжных трёхуровневых приложений для каждого уровня требуется обеспечить непрямой доступ, высокую доступность и балансировку нагрузки.<br>

**Коротко об iptables**<br>
**Iptables** - это инструмент командной строки для управления файерволом на уровне сервера и манипулирования пакетами в Linux.<br>
**Netfilter** - это модуль ядра Linux, содержащий таблицы, цепочки и правила.<br>

Цепочки iptables работают в сетевом пространстве имён, поэтому изменения, сделанные внутри пода, не влияют на другие поды или узел, на котором работает под.<br>
Цепочки iptables, создаваемые Istio, можно исследовать и даже изменять.<br>
Эти цепочки можно увидеть в действии и проверить недостающие возможности NET_ADMIN вашего приложения и контейнеров-сайдкаров при выполнении exec в одном из контейнеров, например:
```
iptables -t nat --list
```
Напомним, что политика управления трафиком настраивается в компоненте Pilot и реализуется прокси.<br>
**Коллекция прокси** называется уровнем данных.<br>
Прокси перехватывает каждый пакет в запросе и отвечают за проверку состояния, маршрутизацию, балансировку нагрузки, аутентификацию, авторизацию и генерацию наблюдаемых сигналов.<br>

**Envoy прокси**<br>
Главным аргументом в пользу использования в Istio прокси-сервера Envoy вместо NGINX стала идея горячей перезагрузки вместо горячих рестартов.<br>
Envoy способен draining и замещать собственный процесс новым процессом с новой конфигурацией.<br>
Envoy выполняет горячую перезагрузку процессов, используя общую память и взаимодействие через Unix Domain Socket.<br>
Кроме того, Envoy предлагает агрегированный сервис обнаружения (ADS) для доставки данных на каждый xDS API.<br>

Envoy совместим с HTTP/1.1 и HTTP/2 и способен передавать оба протокола как вверх, так и вниз.<br>
Также он способен проксировать соединения HTTP/1.1 в HTTP/2 и наоборот.<br>
Envoy изначально поддерживает gRPС (по HTTP/2), а также позволяет соединить клиент HTTP/1.1 по gRPC.<br>
Также он способен работать как транскодер gRPC-JSON. Функциональность транскодера gRPC-JSON позволяет клиенту отправлять запросы HTTP/1.1 с полезной нагрузкой JSON в Envoy, который преобразует запрос в соответствующий вызов gRPC и затем переведёт ответное сообщение обратно в JSON.<br>

**Внедрение вручную**<br>
Можно использовать istioctl в качестве внедрения вручную.<br>
Команда istioctl kube-inject просто добавляет в определение ресурса Pod ещё один контейнер, но фактически ничего не развёртывает.<br>
Команда поддерживает модификацию объектов kubernetes на базе Pod (Job, DaemonSet, ReplicaSet, Pod и Deployment).<br>
Сохранение в файл:
```
istioctl kube-inject -f deployment -o deployment-injected.yaml
istioctl kube-inject -f deployment > deployment-injected.yaml
```
Применение на лету:
```
kubectl apply -f <(istioctl kube-inject -f resource.yaml)
```
Просмотр мутирующих вебхуков:
```
kubectl get mutatingwebhookconfigurations
```
Добавление метки в нэймспейс для инжектирования:
```
kubectl label namespace namespace-name istio-injection=enabled
```

**Init-контейнеры в Kubernetes**<br>
Подобно cloud-init, init-контейнеры в Kubernetes позволяют использовать временные контейнеры для выполнения задачи до подключения основного контейнера (контейнеров). Init-контейнеры часто используются для выполнения задач инициализации ресурсов, таких как объединение активов, миграция баз данных или клонирование Git-репозитория в том.<br>
В случае Istio init-контейнеры используются для настройки сетевых фильтров - iptables, - управляющих трафиком.<br>

**Функциональные возможности Envoy**<br>
Как и другие прокси, Envoy использует сетевые приёмники для приёма входящего трафика.<br>
Термины upstream и downstream описывают направление цепочки связанных между собой запросов.<br>

Основные конструкции:<br>
Приёмник **(listener)** - это именованное сетевое местоположение (например, порт сокета домена Unix и т. д.), принимающее соединения от нижестоящих клиентов.<br>
Envoy выставляет один или несколько приёмников, что во многих случаях является открытым наружу портом, с которым внешние клиенты могут установить соединение.<br>
Приёмник привязывается к определённому порту; физические приёмники используются для пересылки.<br>
Приёмники также могут быть опционально настроены с помощью цепочки принимающих фильтров, каждый из которых может быть использован для работы с метаданными соединения или для лучшей системной интеграции без необходимости внесения изменений в ядро.<br>
Приёмники, маршруты, кластеры и конечные точки можно настраивать **статически**, используя файлы конфигурации, или **динамически**, через соответствующие API:<br>
* сервис обнаружения приёмников (listener discovery service, LDS),
* сервис обнаружения маршрутов (route discovery service, RDS),
* сервис обнаружения кластеров (cluster discovery service, CDS) и
* сервис обнаружение эндпоинтов (endpoint discovery service, EDS).

Статические конфигурационные файлы могут определяться в формате JSON или YAML.<br>
Собирательно набор обнаружения сервисов для API Envoy называется xDS.<br>
Конфигурационный файл определяет объекты listener, route, cluster и endpoint, а также специфические настройки сервера, такие как включение Admin API, куда должны отправляться журналы доступа, и конфигурацию механизма трассировки.<br>

Istio Pilot использует ADS Envoy для динамической конфигурации и централизованно хранит таблицы маршрутизации и определения приёмников и кластеров.<br>
Pilot может применять одни и те же правила к нескольким прокси, что упрощает рассылку обновлений конфигурации прокси в кластере. Во время работы Pilot использует эти API для рассылки конфигурации. Pilot эффективно рассчитывает конфигурацию для каждого сервиса. По умолчанию Pilot рассылает конфигурацию каждый 10 секунд: этот период определяется параметром PILOT_DEBOUNCE_MAX.<br>

Pilot рассылает данные по мере вычисления изменений. Система ADS Envoy гарантирует порядок доставки, позволяя последовательно обновлять прокси в сервисах. Это одно из ключевых свойств, обеспечивающих живучесть сервисной сетки.<br>

Istio-proxy - это контейнер, в котором выполняется два процесса: pilot-agent и Envoy:
```
kubectl exec pod-name -c istio-proxy ps
```
Узнать имя файла конфигурации Envoy в контейнере istio-proxy:
```
kubectl exec pode-name -c istio-proxy ls /etc/istio/proxy
```
Сервис (контейнер приложения) и Envoy используют для связи локальный сетевой интерфейс (loopback).
