# A traffic management
Выполняя функции прокси уровня данных, Envoy перехватывает все входящие и исходящие запросы в режиме реального времени.<br>
Envoy принимает весь входящий сетевой трафик и анализирует запрос, используя имя хоста запроса, SNI или виртуальный IP-адрес сервиса, чтобы определить **цель запроса** (**сервис**, которому клиент намеревается отправить запрос).<br>
Envoy применяет правила маршрутизации для определения **адресата** запроса (сервиса, которому прокси **на самом деле** собирается отправить запрос).<br>
Определив пункт назначения, Envoy применяет правила пункта назначения.<br>
**Правила назначения** включают в себя стратегию балансировки нагрузки, используемую для выбора endpoint'a (endpoint'ом является адрес исполнителя, поддерживающего сервис назначения)<br>
Наконец, Envoy перенаправляет перехваченный запрос в соответствующий endpoint.<br>

Здесь есть ряд важных моментов:<br>
1. Желательноб чтобы приложения взаимодействовали без шифрования с прокси и позволяли ему управлять безопасностью и инкапсулировать трафик в протокол HTTPS.<br>
Это позволяет прокси собирать метаданные L7 о запросах, на основе которых Istio генерирует метрики L7 и манипулирует трафиком на основе политики L7.
2. Нужно выполнять балансировку нагрузки на стороне клиента, а не полагаться на традиционную балансировку через обратные прокси.<br>
Балансировка нагрузки на стороне клиента означает, что можно устанавливать сетевые подключения напрямую от клиентов к серверам, при этом поддерживая надёжную, хорошо работающую систему.<br>
Это, в свою очередь, позволяет использовать более эффективные сетевые топологии с меньшим количеством переходов, чем в традиционных системах, зависящих от обратных прокси.

## Работа сетевых API Istio
В сетевой конфигурации Istio принята **модель адресации на основе имён** (name-centric model), в которой:
* Gateway экспортирует имена;
* VirtualService определяет имена и маршруты к ним;
* DestinationRule описывает, как взаимодействовать с именованными приложениями;
* ServiceEntry позволяет создавать новые имена.

### ServiceEntry
ServiceEntry - это способ ручного добавления/удаления сервисов в реестр (из реестра) Istio.<br>
К сервисам из реестра можно обращаться по именам и ссылаться на них в других конфигурациях Istio.<br>
В простейшем случае ServiceEntry можно использовать для связывания имён с IP-адресами.<br>

Все реестры сервисов, с которыми интегрируется Istio (Kubernetes, Consul, Eureka, etc.) преобразуют свои данные в ServiceEntry.<br>

### DestinationRule
DestinationRule предназначены для настройки клиентов.<br>
Они позволяют администратору сервиса описать как клиент в сетке должен вызывать сервис, включая:
* Подмножества сервисов (например, v1 и v2);<br>
(позволяет разделить один сервис на подмножества с помощью меток и использовать VirtualService для канареечного развёртывания новой версии)
* стратегию балансировки нагрузки, которую должен использовать клиент;
* условия признания конечных точек сервиса неисправными;
* настройки пула соединений L4 и L7;<br>
(число TCP-соединений, разрешённых для каждого узла назначения,<br>
максимальное число повторных попыток для всех эндпоинтов)
* TLS-настройки сервера<br>
как прокси должен защищать соединение с конечной точкой назначения.<br>
Поддерживаются четыре режима:<br>
  - DISABLED:<br>
    Отключает TLS для TCP-соединения
  - SIMPLE:<br>
    Инициирует TLS-соединение с конечной точкой назначения
  - MUTUAL:<br>
    Инициирует mTLS-соединение с конечной точкой назначения
  - ISTIO_MUTUAL<br>
    Запрашивает, использует ли mTLS сертификаты, предоставляемые сеткой Istio.

### VirtualService
**VirtualService описывает направление именованного трафика нескольким получателям.**<br>
Pilot создаёт неявный VirtualService для каждого ServiceEntry.<br>
Хотя адрес для остального трафика явно не задан, любое несовпадение с путями в DestinationRule приведёт к ошибке 404, что можно считать аналогом адреса для необслуживаемого трафика.<br>
VirtualService может сопоставлять запросы по значениям заголовков; порту, к которому пытается подключиться вызывающая сторона; или меткам рабочей нагрузки клиента (например, меткам клиентского пода в Kubernetes) и отправлять только совпадающий трафик на другой адрес.<br>

Важно отметить, что в рамках VirtualService условия совпадения проверяются во время работы в порядке их появления.<br>
Это означает, что первыми должны следовать более строгие условия, а менее строгие - позднее (like if, elif in Python3).<br>

Для безопасности должен быть предусмотрен маршрут "по умолчанию" для трафика, не соответствующего ни одному условию. Потому что запрос, не соответствующий какому-либо условию в VirtualService, приведёт к ошибке 404 на стороне отправителя (или "соединение отклонено" для протоколов, отличных от HTTP).<br>

**Хосты**<br>
Мы говорим, что VirtualService объявляет имя: одно и то же имя хоста может появиться не более чем в одном определении VirtualService, при этом VirtualService может объявить несколько имён хостов.

Наконец, VirtualService может заявить свои права на несколько хостов, описав их с использованием wildcard.<br>
Другими словами, VirtualService может претендовать на хост типа \*.com.<br>
При выборе конфигурации всегда будет применяться наиболее специфический хост: для запроса на baz.foo.com используется VirtualService для baz.foo.com, а VirtualService для \*.foo.com и \*.com игнорируются.

### Gateway
Ресурс Gateway предназначен для экспортирования имён через границы доверия.<br>
Необходимо указывать хост, а также порт и протокол доступа.<br>
Однако для безопасной передачи недостаточно простого отображения имён. Gateway должен быть в состоянии доказать вызывающим абонентам, что он является истинным владельцем имени.<br>
Это можно сделать, настроив Gateway на обслуживание сертификата, например, так:
```
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: foo-com-gateway
spec:
  selector:
    app: gateway-workloads
  servers:
  - hosts:
    - foo.com
    port:
      number: 443
      name: https
      protocol: HTTPS
    tls:
      mode: SIMPLE
      serverCertificate: /etc/certs/foo-com-public.pem
      privateKey: /etc/certs/foo-com-privatekey.pem
```
Согласно лучшим практикам безопасности, рекомендуется настроить Gateway на инкапсуляцию входящего трафика HTTP в протокол HTTPS, пример:
```
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: foo-com-gateway
spec:
  selector:
    app: gateway-workloads
  servers:
  - hosts:
    - foo.com
    port:
      number: 80
      name: http
      protocol: HTTP
    tls:
      httpsRedirect: true # Отправляет 301 редирект для http-запросов
  - hosts:
    - foo.com
    port:
      number: 443
      name: https
      protocol: HTTPS
    tls:
      mode: SIMPLE
      serverCertificate: /etc/certs/foo-com-public.pem
      privateKey: /etc/certs/foo-com-privatekey.pem
```
До сих пор ни один из Gateway не отображал foo.com ни в один сервис в сетке.<br>
Для этого нужно **привязать** VirtualService к Gateway, например:
```
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: foo-com-virtual-service
spec:
  hosts:
  - foo.com
  gateways:
  - foo-com-gateway
  http:
  - route:
  - destination:
    host: webserver.foo.svc.cluster.local
```
Важно понимать, что **Gateway настраивает поведение L4**, а не L7.<br>
Здесь подразумевается, что **Gateway описывает порты и их протоколы**, а также имена (и подтверждение имён посредством сертификатов), которые будут обслуживать эти порты.<br>
Но VirtualService описывает поведение L7.<br>
Поведение L7 состоит в сопоставлении некоторых имён (т. е. foo.com) с различными приложениями и рабочими нагрузками.<br>
Одной из целей разработки Istio было отделение поведения L4 от L7.<br>
Это позволяет создать единое определение Gateway, которое разные команды смогут использовать совместно.<br>

**Рабочие нагрузки**, принадлежащие Gateway, описываются полем **selector** объекта **Gateway**.<br>
Рабочие нагрузки с метками, соответствующими выбранному селектору, рассматриваются в Istio как объекты Gateway.<br>
Когда Istio контролирует реализацию Gateway (т. е. когда в роли шлюза выступает Envoy), можно привязать **VirtualService к Gateway**, чтобы использовать возможности VirtualService в точках входа и выхода нашего кластера.

### Привязка VirtualService к Gateway
VirtualService привязывается к Gateway, если:
* VirtualService включает имя Gateway в своём поле **gateways**;
* по крайней мере один хост, заявленный VirtualService, экспортируется объектом Gateway.

Хосты в конфигурации Gateway объявляются так же, как в VirtualService, но с одним важным отличием.<br>
Gateway не объявляет имена хостов, как это делают VirtualService.<br>
**Gateway экспортирует имя**, позволяя VirtualService настроить передачу трафика к этому имени, путём привязки к Gateway.<br>

Например, любое количество Gateway может содержать имя foo.com, но только один VirtualService должен настроить трафик для него через все Gateway.

### Обнаружение аномалий
**Прерывание цепи** - это схема защиты вызовов (например, сетевых вызовов удалённого сервиса) позади прерывателя цепи (circuit breaker).<br>
Если защищённый вызов возвращает слишком много ошибок, "щелчок" прерывателя возвращает ошибки вызывающему абоненту без выполнения самого защищённого вызова.<br>
В балансировке нагрузки под **отключением конечной точки** понимается **её удаление** из "активного" набора балансировщика нагрузки, чтобы в течение определённого периода времени трафик на неё не посылался.<br>
Отключение - один из методов, который можно использовать для реализации схемы прерывателя цепи.<br>
**Обнаружение аномалий** - это способ отключения эндпоинтов, возвращающих плохие ответы.<br>
Можно определить, когда отдельный эндпоинт ведёт себя аномально по сравнению с остальными в "активном" наборе балансировщика нагрузки (т. е. возвращает больше ошибок, чем другие эндпоинты сервиса), и удалить "плохой" эндпоинт из "активного" набора балансировщика нагрузки в dr:
```
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: foo-default
spec:
  host: foo.default.svc.cluster.local
  trafficPolicy:
    outlierDetection:
      consecutiveErrors: 5
      interval: 1m
      baseEjectionTime: 3m
```
Эндпоинт, давший подряд 5 ошибок, будет выключен на период не менее трёх минут.<br>
Каждую минуту прокси сканирует набор всех эндпоинтов, чтобы решить нужно ли исключать какие-то эндпоинты и можно ли вернуть исключённые точки обратно в набор для балансировки.<br>

Политика повторных попыток, определенная в VirtualService, согласуется с настройками пула соединений, определенными в DestinationRule получателя, чтобы контролировать общее количество одновременных незавершенных попыток получить ответ от этого получателя.<br>

При тестировании ещё может пригодиться возможность отвечать на запросы клиентов определёнными кодами, такими как 439 или 500.<br>
Например, иногда сложно программно протестировать поведение из приложения при неустойчивый работе стороннего сервиса, от которого оно зависит.<br>
Пример имитирующего сбоя в зависимостях:
```
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: foo-default
spec:
  hosts:
  - foo.default.svc.cluster.local
  http:
  - route:
    - destination:
      host: foo.default.svc.cluster.local
    fault:
      abort:
        httpStatus: 500
        percentage:10
```
10% запросов будут завершаться кодом ошибки 500.

### Входные и выходные шлюзы
Ресурсы **Gateway** в развёртывании определяют **границы доверия в сети**.<br>
Другими словами, обычно определения Gateway используются для моделирования прокси на границе сети, контролирующих входящий и исходящий трафики.<br>
Вместе Gateway и VirtualService могут точно контролировать, как трафик входит и выходит из сетки.<br>
Более того, когда сетка Istio разворачивается с включённым определением Policy, появляется возможность применять политику к трафику на входе и выходе из сетки.

### Входной шлюз
После привязки VirtualService к шлюзу весь обычный функционал VirtualService (повторные попытки, внедрение ошибок или управление трафиком) автоматически применяется к входящему трафику.<br>
Во многих отношениях входной шлюз действует как "внешний для кластера прокси на стороне клиента".
