**OpenSSL** — это криптографический инструментарий, реализующий сетевые протоколы **Secure Sockets Layer (SSL v2/v3)**, **Transport Layer Security (TLS v1)** и соответствующие им стандарты криптографии.<br>
**Программа openssl** — это инструмент командной строки для использования различных криптографических функций библиотеки OpenSSL в консоли.<br>
**Openssl кратко**<br>
Основные команды openssl:
* **x509** - утилита для подписи и показа свойств сертификатов
* **req** - утилита для создания запросов на подпись сертификата и для создания самоподписанных сертификатов PKCS#10
* **rsa** — утилита для работы с ключами RSA, например, для конвертации ключей в различные форматы
* **enc** — различные действий с симметричными шифрами
* **s_client** — команда реализует клиент SSL/TLS, который подключается к удалённому хосту с использованием SSL/TLS. Это очень полезный инструмент диагностики для серверов SSL

Чтобы увидеть полный список команд выполните:
```bash
openssl list -commands
```
(Большой обзорный гид см. здесь: https://hackware.ru/?p=12982)<br>
Программой openssl можно генерировать ключи для шифрования разных данных,  здесь, для примера, разобрано использование openssl для шифрования в HTTPS протоколе.<br>
В HTTPS-протоколе используется ассиметричное шифрование.<br>
(В симметричных шифрах есть один ключ, который и шифрует, и дешифрует;
в асимметричных - два ключа: открытый шифрует, закрытый дешифрует;
в электронной подписи тоже два: вычисляется подпись с помощью закрытого, а проверяется открытым.<br>
Пара ассиметричных ключей (закрытый и открытый) называются, соответственно:
**приватный ключ** и **публичный ключ**. Оба ключа генерируются вместе и криптографически связаны.<br>
Приватный ключ должен храниться только у вас, в то время как публичный ключ может свободно распространяться и использоваться для шифрования данных, которые можно расшифровать только приватным ключом.<br>
Также эта пара ключей может использоваться для подписи данных и для проверки этой подписи.<br>
Подпись подтверждает, что данные удостоверены владельцем приватного ключа и впоследствии не были изменены.<br>
Соответственно подписываются данные приватным ключом (который есть строго у одной определённой персоны), а проверять эту подпись можно публичным ключом (который может получить каждый).<br>
Этот подход ограничен сложностью проверки, что публичный ключ выпущен той самой определённой персоной.<br>
Чтобы решить эту сложность, выпущенный публичный ключ можно подписать третьей стороной. В этом случае подписанный публичный ключ вместе с дополнительной информацией (например, название домена, для которого он подписан) упаковывается в **сертификат**.<br>
Сертификат, по сути, это публичный ключ, а также информация о домене и другие сопутствующие сведения, подписанные электронной подписью.<br>
В результате процедура создания сертификата выглядит так.<br>
1. Генерируется приватный и публичный ключ.
2. Публичный ключ вместе с другой информацией для подписи (например, название доменного имени) упаковывается в файл в специальном формате CSR "Certificate Signing Request", то есть запрос на подпись сертификата.
3. Данный запрос на подпись отправляется в Центр Сертификации (CA), который, используя свой приватный корневой ключ, создаёт подпись для этих данных и всё это упаковывается в другой специальный файл, называемый сертификат.
Итоговый сертификат обладает следующими свойствами:
1. Он может зашифровать данные (в нём есть публичный ключ), которые способен расшифровать только приватный ключ, составляющий пару этому сертификату.
2. Сертификат может быть проверен на подлинность (у него есть цифровая подпись), с помощью сертификата Центра Сертификации (CA), который его создал.
[Как это может работать на практике](kafka_connect_with_tls.md)