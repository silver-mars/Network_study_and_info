Допустим у нас есть ПО, расположенное на виртуальной машине в определённом сетевом сегменте (домене).<br>
В нашем случае - это kafka в домене N.<br>
У домена N есть свой Центр Сертификации (CA), имеющий свой корневой приватный ключ.<br>
Любая виртуальная машина в этом домене имеет свою пару ключей и свой сертификат.<br>
Соответственно при любой попытке подключиться в этом домене к любому ресурсу по TLS/SSL-соединению с вас будут спрашивать сертификат, подписанный Центром Сертификации.<br>
Возьмём за базовую задачу научиться подключаться к кафке.<br>
Для этого нам нужно:
1. Пройти процедуру создания сертификата. [Сделать csr и получить успешно подписанный сертификат](csr.md)
2. Добавить этот сертификат в jks - java keystore - специальное хранилище сертификатов для приложений, работающих на java.
Как только ваш сертификат будет создан и в него будет добавлена необходимая цепочка корневых сертификатов, вы сможете успешно подключаться к самой кафке.<br>

**Важные нюансы:**<br>
сертификаты делятся на:
* клиентский
* серверный
* универсальный (клиент-сервер)

В нашем случае необходим именно клиентский сертификат.<br>
Зачем это нужно?<br>
Кафка выступает как сервер, к которому мы будем подключаться как клиенты: писать сообщения в топики или вычитывать их.<br>
Поэтому в сертификате вам необходимо указать идентифицирующий вас [**CommonName**](tls_glossary.md)<br>
Для сравнения, если бы вы создавали серверный сертификат, у вас вместо **CommonName** был бы доменный адрес, url, где располагается сервер.<br>
Также у кафки есть механизм **ACL (Access Control List)** - список управления доступом.<br>
Механизм ACL определяет, кто или что может получать доступ к объекту (программе, процессу или файлу), а также какие именно операции разрешено или запрещено выполнять субъекту (пользователю, группе пользователей).<br>
В случае с кафкой основные операции - это чтение информации из топиков, запись к ним и изменение свойств топиков.<br>
Соответственно те данные, которые вы укажете в CommonName, должны быть добавлены в ACL кафки.
