grep:
grep WARN /var/log -c = count.
'\<seven' - begin word.
'seven\>' - end word.
'^seven' - begin line.
'seven$' - end line.
grep -E "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" - пример поиска по ip.
grep something | grep -v '#' - убрать строку с комментарием.
grep -oE '\b[0-9]{1,3}(\.[0-9]{1,3}){3}\b' /etc/resolv.conf | grep -v '#' - Показать только сами ip. Check.

    -d file — истина, если file существует и является каталогом
    -e file — истина, если file существует
    -f file — истина, если file существует и является обычным файлом
    -r file — истина, если file существует и доступен для чтения
    -s file — истина, если file существует и имеет размер больше, чем ноль
    -w file — истина, если file существует и доступен для записи
    -x file — истина, если file существует и доступен для выполнения
    -L file — истина, если file существует и является символьной ссылкой
    file1 -nt file2 — истина, если file1 новее (дата модификации), чем file2
    file1 -ot file2 — истина, если file1 старее, чем file2

[ — это алиас встроенной команды test. У них одинаковые ограничения. [[ — более продвинутая версия.

[ использует для проверки строк на совпадение операторы = и !=.
[[ использует ==, != и =~, при этом правый аргумент расценивается как регулярное выражение, а не как строка, если не взят в кавычки.

a="abcdef"; b="abc"; [ "$a" = "$b" ] && echo '1 matches!'; [[ "$a" == "$b"* ]] && echo '2 matches!'

Собственно, поэтому аргументы, указанные в [[ не подвергаются pathname expansion, то есть
[[ "$a" == "$b"* ]]
будет всегда расцениваться, как «начинается ли то, что лежит в $a с $b?», в то время как
[ "$a" = "$b"* ]
тоже верная конструкция, которая означает «раскрыть $b* до всех соответствующих имён в текущем каталоге и сравнить со строкой из $a». При этом если мы в пустом каталоге сделаем…
a='abcdef'
b='abc'
touch abcdef
[ "$a" = "$b"* ] && 'existed!'
то увидим «existed!», произошла проверка на имя файла. А если сразу после этого…
touch abcedf abcfed
[ "$a" = "$b"* ] && 'existed!'
то ответом будет
bash: [: too many arguments
Правый аргумент раскрылся во множество строк каждая с именем существующего файла, и это вызвало ошибку, потому что = ожидает только один аргумент после себя.
Операторы > и < в обоих командах сравнивают строки лексически, но [ сравнивает по ASCII, а [[ – используя локаль, которая может быть хоть С, хоть из UTF-8. Логические операторы просто называются по-разному, [ использует -a и -o, а [[ – && и || соответственно.
Использование [[ оправдано только там, где оно необходимо и необходимость эта обоснована.

Сравнение строк делается [ «blah» = «blah» ].
-eq для сравнения целых чисел.
