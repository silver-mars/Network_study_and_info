# Непрерывный мониторинг

ELK - аббревиатура, используемая для описания стека из трёх популярных проектов: ElasticSearch, Logstash и Kibana.
Стек ELK, зачастую именуемый Elasticsearch, предоставляет возможность собирать журналы всех ваших систем и приложений, анализировать их и создавать визуализации, чтобы мониторить приложения и инфраструктуры, быстрее устранять неполадки, анализировать систему безопасности и многое другое.
**Elasticsearch** - распределённый поисковый и аналитический движок на базе Apache Lucene.
**Logstash** - это предназначенный для приёма данных инструмент с открытым исходным кодом, который позволяет собирать данные из различных источников, преобразовывать их и отправлять в нужное место назначения.
**Kibana** - это инструмент визуализации и изучения данных для просмотра журналов и событий. Kibana предлагает простые в использовании интерактивные диаграммы, встроенные агрегаторы и фильтры, а также геопространственную поддержку, благодаря чему является предпочтительным выбором для визуализации данных, хранящихся в Elasticsearch.

1. Logstash собирает, преобразует и отправляет данные в нужный пункт назначения.
2. Elasticsearch индексирует и анализирует собранные данные и производит поиск в них.
3. Kibana предоставляет визуализацию результатов анализа.

docker-compose.yaml for this decision is here:
https://habr.com/ru/articles/671344/

**Graylog**:
https://habr.com/ru/articles/556194/

# Infrastructura as a code

Подход, при котором инфраструктура описана в виде кода и хранится в СКВ.
Общий язык для команды разработки и команды эксплуатации.
Подпрактика инфраструктуры как код - это **управление версиями**. Это ansible, chief, etc. В них входит:
* Распределённые СКВ
* Интеграция багтрекера и СКВ
* Понятный и автоматизированный процесс создания релиза "по кнопке"
* Code review, pull request и др. хранится в СКВ.

В понятие **микросервисы** входит:
* Децентрализованное управление данными
* Самодостаточность и изолированность
(можем провести smoke-test, запустился, подключился, на холостом ходу ошибок нет)
* Публичное API
* Сервис умеет сам себя обслуживать на основе других сервисов

С точки зрения эксплуатации для того, чтобы получить микросервис, нам нужны:
* Автоматизация инфраструктуры
* Отказоустойчивость
(в них изначально заложена возможность работы с отказом: перезапуск или что-либо иное.
Исходим из парадигмы, что всё может упасть и проектируем с учётом этого (retry-topic'и кафки и т. д. - сюда же).
* Асинхронность
* DDD
(Domain Driven Design?)
* Способность постоянно развивать микросервис

**Достоинства**:
* Возможность использования любых языков и фреймворков
(к каждой задаче можно подобрать наилучший инструмент)
* Небольшие компоненты
* Слабая связность
* Лёгкость обновления
(не нужно обновлять по 4-6 часов как монолиты)

**Недостатки**:
* Сложно выкатывать
(не нарушена ли совместимость со всеми остальными задействованными микросервисами?)
* Сложно тестировать
* Распределённая система
* Сложно эксплуатировать
* Несогласованная БД

**Производство цифровых продуктов**.

**Гипотеза**.
**Код** - minimal valuable product - что уже можно выкатить на рынок, чтобы проверить востребован ли этот продукт?
Здесь уже мониторинг, логирование.
**Контроль качества** - форма договора среди команд, каким ПО должно попасть на стадию интеграции.
Что минимально необходимо для перехода в стадию интеграции.
**Интеграция** - коллаборация, chatops - распределённая коллаборация, позволяющая отдельные куски интегрировать вместе.
**Production**.
**Обратная связь**.

# Модель Base, Service, App
Универсальная технологическая модель организации devops.

-----------------------------------------------------
|Layer                              |Responsibility |
-----------------------------------------------------
|Application                        |DevOps         |
-----------------------------------------------------
|Service (IIS, MS SQL, MongoDB)     |Ops            |
-----------------------------------------------------
|Base (Windows, Linux)              |Ops            |
-----------------------------------------------------
**Base** - системные администраторы.
**Сервисный уровень** - это базы данных, хэши, очереди, авторизационные сервисы, хранилища данных.
То, что устанавливается извне как часть платформы и требует обслуживания.
Система для хранения и анализа данных.
Разработчики.

**Четыре базовые devops-компетенции**

* Разработчик с представлением об архитектуре и работе софта в продакшене (пишет тесты и инфраструктурный код)
* Инфраструктурный инженер (пишет обвязки для инфраструктуры, предоставляет разработчику платформу)
(настраивает kubernetes, пишет ansible-playbooks, инфраструктура как код и т. д.)
* Разработчик инфраструктурных сервисов (DBaS, Monitoring as Service, Logging as Service)
* Релиз-менеджер (управляет процессом и зависимостями).

Все 4 компетенции подразумевают владение базовыми практиками.

Для самостоятельного ознакомления:
**Книжка Continious Delivery**

# Система контроля версий. VCS

Нужно для контроля релизов (система версионирования).

Типы систем конроля версий.

* Centralize VCS
Клиент-серверная модель. Разработчику нужно быть на связи с центральным сервером.

* Distributed VCS
У каждого разработчика на локальной машине сохраняется полная версия проекта.
Не нужно общаться с центральным сервером, чтобы скачать себе на машину локальную версию документа, директории или достать другие данные.

**Плюсы DVCS**
* Полноценная локальная копия проекта
* Локальный репозиторий ~ бэкап
В случае падения центрального сервера - если он недоступен - локальная копия разработчика может использоваться для полноценного восстановления.
* Можно работать оффлайн
Работать можно хоть в лесу.
* Скорость
Так как не нужно постоянно устанавливать соединение с центральным сервером.

**Принципы работы GIT'a**

**Хранение изменений**
Любое изменение, любой коммит представляет собой слепок всей структуры репозитория: **snapshot format**.
Любое изменение файла влечёт за собой сохранение нового объекта, содержимое файла сохраняется полностью.
Если файл не изменился, сохраняется ссылка на предыдущую версию файла.

**Сохранение истории** хранится в локальном репозитории в директории .git в корне проекта.
Репозиторий хранит: объекты коммитов, ссылки на коммиты и ветки, конфигурацию и др.

**Как хранятся изменения**
Гит хранит всю информацию в виде объектов и при любом коммите, который мы делаем как минимум создаются три объекта.

4 типа хранимых объектов:
* blob
* tree
* commit
* tag

**blob** - базовая единица хранения данных в Git.
Хранит snapshot (снимок) содержимого файла.

В качестве имени объекта берётся SHA1 хэш содержимого файла и заголовка.

Команда **git cat-file -t file_name** - выводит тип (blob)
Команда **git cat-file -p file_name** - выводит содержимое файла.

# Разобраться с этим самостоятельно подробнее.
# Важно - понять как вообще искать эти типы blob, точно знать где именно они содержатся.

**tree**
Деревья содержат информацию о блобах, а также других поддеревьях.
Деревья решают проблему хранения имён файлов и их группировки по директориям.

blob - хранит содержимое одного файла, он не содержит имени этого файла.
Деревья позволяют хранить структуру репозитория. Они хранят имена файлов: ставят соответствие между именами файлов и соответствующим им блобам.

Таким образом при помощи деревьев и блобов мы можем организовать процесс создания слепка репозитория.

Контентно-адресуемая файловая система.
**Content-addressable storage** (CAS) — архитектура хранения, в которой адресация осуществляется образом хранимых данных.
Образ данных хешируется и хеш используется для его нахождения на устройствах или системах хранения.

**Свойства CAS-устройств**
1. Неизменяемость данных.
Сама архитектура системы гарантирует неизменность хранимой информации. Если какой-либо объект был изменён, то у него будет уже другая контрольная сумма, и это будет уже другой объект, хранимый по другому адресу. При обращении по старому адресу объект будет прочтён в гарантированно первозданном виде, что исключает подмену, подделку и иные подобные действия, что неоценимо в области юриспруденции, безопасности, хранения ключевых доказательств и др.

2. Авторизированное и сертифицированное удаление (Audited delete, Reflections)
Удаление объекта в устройстве не происходит бесследно. Помимо того, что для этого могут потребоваться определённые права доступа, а также авторизация вышестоящего руководства, после удаления объекта остаётся определённая информация о факте удаления, а также о связанных с ним объектах и персонах. Так например устройство позволяет создать хранилище записей камер видеонаблюдения, которое позволяет установить был ли факт наличия/отсутствия определённых записей, а также пользователей, причастных к их удалению. 

3. Единственность копии (Single Instance Storage)
Следствием архитектуры CAS является ещё одна интересная особенность: в случае, если записываются несколько одинаковых файлов, но под разными именами, то реально будет записан только один объект, так как контрольные суммы — и следовательно, адреса размещения всех объектов - совпадут, что значительно экономит дисковое пространство. Однако же при чтении каждый файл будет читаться под своим именем. 

**commit**
Информация о том, кто делает коммит.
Включает в себя:
* Автор, коммитер, дата
* Цифровая подпись
* Сообщение
* Дерево (ссылается на определённое дерево)
* Родитель или родители

**tags**
Два типа:
* Легковесные теги - указатели на определённый коммит
* Аннотированные - содержат имя, email, поставившего тег, дату, комментарий и могут иметь цифровую подпись.
Хранятся как полноценные объекты.

**Git workflow**
1. Начинаем работать в рабочей директории.
Вносим изменения и выбираем их для коммита.
2. Изменения заносятся в Index (Stage) - промежуточная стадия, буферная зона для создания новых коммитов. **git add**
3. Сохраняем изменения в локальный репозиторий .git
4. После этого мы можем поделиться изменениями с другими, например, запушив их в локальный репозиторий.

**Основные команды для работы с git**

1. **git init**
Создать репозиторий в папке с проектом:
git init /path/to/project/folder
git init . # - создать репозиторий в текущей директории
Будет создана папка .git
Теперь можно начать отслеживать историю нашего проекта.

2. **git status**
On branch <...>
**Changes to be committed**:
то, что добавится к коммиту (внесено в индекс).
**Changes not staged for commit**:
не внесено в индекс.
**Untracked files**:
файлы, о которых гит ничего не знает (их раньше не было в локальном репозитории).

**Состояния файлов**
**Untracked** - файл, которого раньше не содержалось в проекте.
**Staged** - файл, который мы добавили в stage, index
**Unmodified** - файл, который был закоммичен.
**Modified** - файл, который был раньше в репозитории, но впоследствии изменился и не был добавлен в index.

3. **git commit --ammend -m "new mesage"** # правка последнего коммита. Добавление/изменение файлов прям в нём и правка прикреплённого к нему message.

4. **git revert** # делает новый (обратный) коммит.
Не меняет истории - безопасный способ откатить изменения. Стоит использовать для публичных коммитов.

5. **git reset HEAD~1** # удаляет коммиты после указанного.
Конкретно данная команда удаляет текущий коммит (из истории в т. ч.) и откатывается на предыдущий.
Так как эта команда меняет историю - это небезопасный способ отката изменений. Можно использовать для локальных коммитов.

**branches**
Ветки - это подвижный указатель на коммит.
Переключение по веткам осуществляется за счёт другого подвижного указателя **HEAD**, указывающего на текущую ветку.
Текущий указатель автоматом сдвигается после каждого нового коммита.

По умолчанию создание новой ветки **git branch new_branch_name** просто
**создаёт новый указатель** на текущий коммит.

**git log --graph --abbrev-commit --decorate --all --oneline**
команда, которая показывает структуру веток в виде графа.
Рекомендуется сделать для неё alias.

**Добавление изменений**

1. **git merge**
На примере двух веток: **master** и **feature**.
Когда работа в ветке feature завершена, выполняются следующие команды:
**git checkout master**
**git merge feature** - мы вливаем в ветку master ветку feature.

2. **git rebase**
**git checkout feature**
**git rebase master** # меняем основание ветки feature.

Смысл этой команды в смене основания ветки
Все коммиты, которые были ответвлены от определённого коммита ветки master, переносятся на последний актуальный коммит ветки master, как если бы они продолжались после него.

**Опасности rebase**
* Если ветка опубликована и её кто-то начал использовать - вы ломаете историю.
* Если вы разрешили конфликты, то они могут появиться снова, поскольку коммиты из ветки принимаются по одному поочерёдно на новое основание.

**fast-forward merge**
Перемещение указателя на новый коммит.
# Но посмотреть дополнительно материалы на эту тему.

**Конфликты**
Простейший пример возникновения - в одном и том же файле в двух коммитах поменяли одинаковую строку.

cat file.txt

commit 1
commit 2
<<<<<<< HEAD
commit 4
=======
commit 3
>>>>>>> feature

vim file.txt;
git add file.txt
git commit -m "Merge branch feature"

**git show <commit>**
Показать коммит:
Позволяет посмотреть информацию по конкретным коммитам
**git show master** # показать коммит, на который ссылается master

Также есть дополнительные спецификаторы:
**git show master^** # родитель этого коммита
**git show master~2** # дедушка этого коммита

Идентичными указателями являются:
master^ master~
master^^ master~2

master^2 # второй родитель
master^2^ # дедушка второго родителя

**git diff** - показывает непроиндексированные изменения
Изменения, которые содержатся только в локальном репозитории.
**git diff --cached** # изменения, которые добавили в индекс
**git diff branch..master** # сравнить два коммита.

**git log** # показывает коммиты одной ветки
**git log --all** # показывает все коммиты
**git log -p** # показывает дельту изменений
**git log --graph --all** # рисует граф ветвлений
**git log --oneline** # выводит коммиты в одну строку.

**Поиск проблемного коммита**

1. **Аннотация файла**
Посмотреть какие коммиты изменяли каждую строку файла в последний раз.
**git blame file.txt**

2. **Бинарный поиск**
Используется когда вы не знаете где ошибка.
**git bisect** - позволяет выделить массив коммитов, по которым ведётся поиск.
**git bisect start** - инициация
**git bisect bad** - пометить как "плохой".
**git bisect good v3.0.0** - помечаем хороший коммит.

Дальше гит показывает нам срединный коммит между метками и спрашивает хороший он или плохой.
**!!!!Важно!!!!**
Эта команда поддаётся автоматизации. Мы можем запускать скрипт, проверяющий каждый коммит и возвращающий ноль или единицу.

**Конфигурация пользователя**
* ~/.gitconfig # Linux
* $HOME\.gitconfig # Windows
* git config --help

**Основные секции**
[user]
  name = awesome_name
  email = awesome@mail.com
[color]
  ui = auto
[alias]
  co = checkout
  st = status

**git remote -v** - посмотреть информацию об удалённых репозиториях.
**git remote show origin** - посмотреть полную команду об удалённом репозитории.

При копировании репозитория на локальный компьютер командой **git clone**
наша ссылка на удалённый репозиторий выглядит как **origin/master**, где **origin** - это ссылка на тот самый удалённый репозиторий, а **master** - ссылка на удалённую ветку.
Т. е. это указатель на удалённую ветку репозитория.

**git fetch** - забирает данные с удалённого репозитория, но не применяет их.
**git merge** - команда для сбора изменений.
**git pull** = автоматически последовательное применение команд **git fetch** + **git merge**.

**git pull --rebase**
Подтягивает изменения из удалённого репозитория и те изменения, что мы сделали в локальном репозитории, она переносит поверх подтянутых изменений.
* **git fetch + git rebase**
* Не будут создаваться дополнительные merge коммиты.

**git push**
Обновляет удалённую ветку в соответствии с локальной

**Типы веток**
1. **Remote** (удалённые) - ветки в удалённом репозитории.
2. **Remote-tracking** (отслеживающие удалённые) - локальные указатели на удалённые ветки.
Просто указатель на коммит, на который смотрит удалённая ветка.
Чтобы общаться с удалённой веткой, нужно постоянно подтягивать изменения.
Если кто-то запушил изменения в удалённый репозиторий, нам нужно забрать изменения, на которые целит удалённый указатель.
3. **Non-tracking local** (неотслеживающие) - локальные ветки, не привязанные ни к какой удалённой ветке.
Просто локальная ветка, не сообщающаяся с удалённым репозиторием.
4. **Tracking local** (отслеживающие) - локальные ветки, напрямую связанные с удалёнными ветками.
Работают команды git pull, git push, git fetch.

**git branch -vv** - команда, позволяющая получить информацию о типах веток.

**git flow**
https://habr.com/ru/articles/106912/
http://nvie.com/posts/a-successful-git-branching-model/
https://github.com/nvie/gitflow
* master, develop, release, feature and hotfix branches

**Peer review**
Может выполняться на что угодно, в т. ч. документацию и не только. Подразумевает:
* минимум две пары глаз на каждое изменение
* коллективное владение кодом
* сложно не технически, а эмоционально
важно правильно давать комментарий
* удобно делать через pull-requests

**git help -a** - краткая сводка по командам.
Ни один графический интерфейс не реализует всего объёма функционала гита.

Что почитать:
https://git-scm.com/book/ru/v2

**pull request**
Предотвращение рисков при слиянии изменений из одной ветки в другую.
Запрос: я сделал такие-то коммиты, посмотрите, прежде чем смёрджить.


# Git
https://webhamster.ru/mytetrashare/index/mtb0/1403437294p5cpqb1b39?ysclid=lk9d1z5j5z731002221
